

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>alkali_atom_functions &mdash; ARC - Alkali Rydberg Calculator 0.9 beta documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/arc_logo.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="ARC - Alkali Rydberg Calculator 0.9 beta documentation" href="../index.html"/>
        <link rel="up" title="Module code" href="index.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> ARC - Alkali Rydberg Calculator
          

          
            
            <img src="../_static/logo_small.png" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                0.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting started with ARC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../detailed_doc.html">Detailed documentation of functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute.html">How to contribute to the project</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">ARC - Alkali Rydberg Calculator</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Module code</a> &raquo;</li>
      
    <li>alkali_atom_functions</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for alkali_atom_functions</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Implements general single-atom calculations</span>

<span class="sd">This module calculates single (isolated) atom properties of all alkali metals in </span>
<span class="sd">general. For example, it calculates dipole matrix elements, quandrupole matrix </span>
<span class="sd">elements, etc.  Also, some helpful general functions are here, e.g. for saving</span>
<span class="sd">and loading calculations (single-atom and pair-state based), printing state </span>
<span class="sd">labels etc.</span>


<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">exp</span><span class="p">,</span><span class="n">log</span><span class="p">,</span><span class="n">sqrt</span>
<span class="c1">#from pylab import *</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.ticker</span> <span class="k">import</span> <span class="n">MultipleLocator</span><span class="p">,</span> <span class="n">FormatStrFormatter</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="c1">#from algebra_nikola import *</span>
<span class="kn">from</span> <span class="nn">wigner</span> <span class="k">import</span> <span class="n">Wigner6j</span><span class="p">,</span><span class="n">Wigner3j</span><span class="p">,</span><span class="n">wignerD</span><span class="p">,</span><span class="n">CG</span><span class="p">,</span><span class="n">wignerDmatrix</span>
<span class="kn">from</span> <span class="nn">scipy.constants</span> <span class="k">import</span> <span class="n">physical_constants</span><span class="p">,</span><span class="n">pi</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">epsilon_0</span><span class="p">,</span><span class="n">hbar</span>
<span class="kn">from</span> <span class="nn">scipy.constants</span> <span class="k">import</span> <span class="n">e</span> <span class="k">as</span> <span class="n">elemCharge</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">curve_fit</span>

<span class="c1"># for matrices</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">zeros</span><span class="p">,</span><span class="n">savetxt</span><span class="p">,</span> <span class="n">complex64</span><span class="p">,</span><span class="n">complex128</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="k">import</span> <span class="n">eigvalsh</span><span class="p">,</span><span class="n">eig</span><span class="p">,</span><span class="n">eigh</span>
<span class="kn">from</span> <span class="nn">numpy.ma</span> <span class="k">import</span> <span class="n">conjugate</span>
<span class="kn">from</span> <span class="nn">numpy.lib.polynomial</span> <span class="k">import</span> <span class="n">real</span>

<span class="c1">#from wigner_rotation import wignerD</span>

<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="k">import</span> <span class="n">csr_matrix</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="k">import</span> <span class="n">kron</span> <span class="k">as</span> <span class="n">kroneckerp</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="k">import</span> <span class="n">eigsh</span>
<span class="kn">from</span> <span class="nn">scipy.special.specfun</span> <span class="k">import</span> <span class="n">fcoef</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">floor</span>
<span class="c1">#from scipy.integrate import ode</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># for calling C++ Numerov </span>
<span class="kn">import</span> <span class="nn">shlex</span>
<span class="kn">from</span> <span class="nn">subprocess</span> <span class="k">import</span> <span class="n">Popen</span><span class="p">,</span> <span class="n">PIPE</span>
<span class="c1">#from idlelib import OutputWindow</span>

<span class="c1"># START of modules for online (server) execution</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span><span class="nn">platform</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="c1">#from nbconvert.exporters.exporter import FilenameExtension</span>
<span class="c1"># END of modules for online (server) execution </span>

<span class="kn">import</span> <span class="nn">cPickle</span> <span class="k">as</span> <span class="nn">pickle</span>   <span class="c1"># fast, C implementation of the pickle</span>
<span class="kn">import</span> <span class="nn">gzip</span>

<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">sqlite3</span>



<div class="viewcode-block" id="AlkaliAtom"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom">[docs]</a><span class="k">class</span> <span class="nc">AlkaliAtom</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implements general calculations for alkali atoms.</span>
<span class="sd">        </span>
<span class="sd">        This abstract class implements general calculations methods.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            preferQuantumDefects (bool):</span>
<span class="sd">                Use quantum defects for energy level calculations. If False,</span>
<span class="sd">                uses NIST ASD values</span>
<span class="sd">                where available. If True, uses quantum defects for energy calculations</span>
<span class="sd">                for principal quantum numbers equal or above</span>
<span class="sd">                :obj:`minQuantumDefectN` which is specified for each element</span>
<span class="sd">                separately. For principal quantum numbers below this value,</span>
<span class="sd">                NIST ASD values are used, since quantum defects don&#39;t reproduce</span>
<span class="sd">                well low-lying states. Default is True.</span>
<span class="sd">            cpp_numerov (bool):</span>
<span class="sd">                should the wavefunction be calculated with Numerov algorithm</span>
<span class="sd">                implemented in C++; if False, it uses pure Python implementation</span>
<span class="sd">                that is much slower. Default is True.</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="c1"># ALL PARAMETERS ARE IN ATOMIC UNITS (Hatree)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">137.0</span>   <span class="c1">#: Hyperfine constant</span>
    
    <span class="n">a1</span><span class="p">,</span><span class="n">a2</span><span class="p">,</span><span class="n">a3</span><span class="p">,</span><span class="n">a4</span><span class="p">,</span><span class="n">rc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Model potential parameters fitted from experimental observations for </span>
<span class="sd">        different l (electron angular momentum)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alphaC</span> <span class="o">=</span> <span class="mf">0.0</span>    <span class="c1">#: Core polarizability</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="mf">0.0</span>       <span class="c1">#: Atomic number</span>
    
    <span class="n">sEnergy</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">NISTdataLevels</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">scaledRydbergConstant</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="n">quantumDefect</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],</span>\
                      <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],</span>\
                      <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">]],</span>
                     <span class="p">[[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],</span>\
                      <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],</span>\
                      <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">]]]</span>
    <span class="sd">&quot;&quot;&quot; Contains list of modified Rydberg-Ritz coefficients for calculating </span>
<span class="sd">        quantum defects for [[ :math:`S_{1/2},P_{1/2},D_{3/2},F_{5/2}`],</span>
<span class="sd">        [ :math:`S_{1/2},P_{3/2},D_{5/2},F_{7/2}`]].&quot;&quot;&quot;</span>
    
    <span class="n">levelDataFromNIST</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>                  <span class="c1">#: location of stored NIST values of measured energy levels in eV</span>
    <span class="n">dipoleMatrixElementFile</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>            <span class="c1">#: location of hard-disk stored dipole matrix elements</span>
    <span class="n">quadrupoleMatrixElementFile</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>        <span class="c1">#: location of hard-disk stored dipole matrix elements</span>
    
    <span class="n">dataFolder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">__file__</span><span class="p">)),</span><span class="s2">&quot;data&quot;</span><span class="p">)</span>
    
    <span class="c1"># now additional literature sources of dipole matrix elements</span>
    
    <span class="n">literatureDMEfilename</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filename of the additional literature source values of dipole matrix </span>
<span class="sd">        elements.</span>
<span class="sd">        </span>
<span class="sd">        These additional values should be saved as reduced dipole matrix elements </span>
<span class="sd">        in J basis.</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="c1">#: levels that are for smaller principal quantum number (n) than ground level, but are above in energy due to angular part</span>
    <span class="n">extraLevels</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1">#: principal quantum number for the ground state</span>
    <span class="n">groundStateN</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1">#: swich - should the wavefunction be calculated with Numerov algorithm implemented in C++</span>
    <span class="n">cpp_numerov</span> <span class="o">=</span> <span class="kc">True</span>
    
    <span class="n">mass</span> <span class="o">=</span> <span class="mf">0.</span>  <span class="c1">#: atomic mass in kg</span>
    <span class="n">abundance</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1">#: relative isotope abundance</span>
    
    <span class="n">elementName</span> <span class="o">=</span> <span class="s2">&quot;elementName&quot;</span>  <span class="c1">#: Human-readable element name</span>
    
    <span class="n">preferQuantumDefects</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">minQuantumDefectN</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1">#: minimal quantum number for which quantum defects can be used; uses measured energy levels otherwise</span>
    
    <span class="c1"># SQLite connection and cursor</span>
    <span class="n">conn</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">c</span> <span class="o">=</span> <span class="kc">False</span>
    
    <span class="c1"># Name of precompiled executable for C/C++ module for Numerov integration</span>
    <span class="n">numerovExec</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">preferQuantumDefects</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">cpp_numerov</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        
        <span class="c1"># should the wavefunction be calculated with Numerov algorithm implemented in C++; if false, it uses Python implementation that is much slower</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cpp_numerov</span> <span class="o">=</span> <span class="n">cpp_numerov</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preferQuantumDefects</span> <span class="o">=</span> <span class="n">preferQuantumDefects</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_databaseInit</span><span class="p">()</span>
        <span class="c1">#self.conn = sqlite3.connect(self.dataFolder+self.precalculatedDB)</span>
        <span class="c1">#self.c = self.conn.cursor()</span>
        
        <span class="c1"># load dipole matrix elements previously calculated</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dipoleMatrixElementFile</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">preferQuantumDefects</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dipoleMatrixElementFile</span>  <span class="o">=</span> <span class="s2">&quot;NIST_&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">dipoleMatrixElementFile</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataFolder</span><span class="p">,</span>\
                                            <span class="bp">self</span><span class="o">.</span><span class="n">dipoleMatrixElementFile</span><span class="p">))</span> 
                <span class="c1"># save to SQLite database</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;SELECT COUNT(*) FROM sqlite_master </span>
<span class="s1">                                    WHERE type=&#39;table&#39; AND name=&#39;dipoleME&#39;;&#39;&#39;&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="c1"># create table</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;CREATE TABLE IF NOT EXISTS dipoleME</span>
<span class="s1">                         (n1 TINYINT UNSIGNED, l1 TINYINT UNSIGNED, j1_x2 TINYINT UNSIGNED,</span>
<span class="s1">                         n2 TINYINT UNSIGNED, l2 TINYINT UNSIGNED, j2_x2 TINYINT UNSIGNED,</span>
<span class="s1">                         dme DOUBLE,</span>
<span class="s1">                         PRIMARY KEY (n1,l1,j1_x2,n2,l2,j2_x2)</span>
<span class="s1">                        ) &#39;&#39;&#39;</span><span class="p">)</span>
                        <span class="n">data</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span>  <span class="c1"># j1 -&gt; 2 x j1 (bacause database has int values)</span>
                        <span class="n">data</span><span class="p">[:,</span><span class="mi">5</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span>  <span class="c1"># j2 -&gt; 2 x j2 (bacause database has int values)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s1">&#39;INSERT INTO dipoleME VALUES (?,?,?,?,?,?,?)&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
                <span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">Error</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span> <span class="s2">&quot;Error while loading precalculated values into the database&quot;</span>
                    <span class="nb">print</span> <span class="n">e</span>
                    <span class="n">exit</span><span class="p">()</span>  
                    
            <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s2">&quot;Error reading dipoleMatrixElement File &quot;</span><span class="o">+</span>\
                    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataFolder</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dipoleMatrixElementFile</span><span class="p">)</span>
                <span class="nb">print</span> <span class="n">e</span>
               
        <span class="c1"># load quadrupole matrix elements previously calculated        </span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quadrupoleMatrixElementFile</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">preferQuantumDefects</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">quadrupoleMatrixElementFile</span>  <span class="o">=</span> <span class="s2">&quot;NIST_&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">quadrupoleMatrixElementFile</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataFolder</span><span class="p">,</span>\
                                            <span class="bp">self</span><span class="o">.</span><span class="n">quadrupoleMatrixElementFile</span><span class="p">))</span>
                <span class="c1"># save to SQLite database</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;SELECT COUNT(*) FROM sqlite_master </span>
<span class="s1">                                    WHERE type=&#39;table&#39; AND name=&#39;quadrupoleME&#39;;&#39;&#39;&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="c1"># create table</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;CREATE TABLE IF NOT EXISTS quadrupoleME</span>
<span class="s1">                         (n1 TINYINT UNSIGNED, l1 TINYINT UNSIGNED, j1_x2 TINYINT UNSIGNED,</span>
<span class="s1">                         n2 TINYINT UNSIGNED, l2 TINYINT UNSIGNED, j2_x2 TINYINT UNSIGNED,</span>
<span class="s1">                         qme DOUBLE,</span>
<span class="s1">                         PRIMARY KEY (n1,l1,j1_x2,n2,l2,j2_x2)</span>
<span class="s1">                        ) &#39;&#39;&#39;</span><span class="p">)</span>
                        <span class="n">data</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span>  <span class="c1"># j1 -&gt; 2 x j1 (bacause database has int values)</span>
                        <span class="n">data</span><span class="p">[:,</span><span class="mi">5</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span>  <span class="c1"># j2 -&gt; 2 x j2 (bacause database has int values)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s1">&#39;INSERT INTO quadrupoleME VALUES (?,?,?,?,?,?,?)&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
                <span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">Error</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span> <span class="s2">&quot;Error while loading precalculated values into the database&quot;</span>
                    <span class="nb">print</span> <span class="n">e</span>
                    <span class="n">exit</span><span class="p">()</span> 
                    
            <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s2">&quot;Error reading quadrupoleMatrixElementFile File &quot;</span><span class="o">+</span>\
                    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataFolder</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">quadrupoleMatrixElementFile</span><span class="p">)</span>
                <span class="nb">print</span> <span class="n">e</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">sEnergy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">NISTdataLevels</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">NISTdataLevels</span><span class="p">)</span>

        
        <span class="c1"># Always load NIST data on measured energy levels;</span>
        <span class="c1"># Even when user wants to use quantum defects, qunatum defects for</span>
        <span class="c1"># lowest lying state are not always so accurate, so below the</span>
        <span class="c1"># minQuantumDefectN cut-off (defined for each element separately)</span>
        <span class="c1"># getEnergy(...) will always return measured, not calculated energy levels</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levelDataFromNIST</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
            <span class="nb">print</span> <span class="s2">&quot;NIST level data file not specified. Only quantum defects will be used.&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parseLevelsFromNIST</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataFolder</span><span class="p">,</span>\
                                               <span class="bp">self</span><span class="o">.</span><span class="n">levelDataFromNIST</span><span class="p">))</span>
            <span class="n">br</span> <span class="o">=</span> <span class="mi">0</span>
            
            <span class="k">while</span> <span class="n">br</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_addEnergy</span><span class="p">(</span><span class="n">levels</span><span class="p">[</span><span class="n">br</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">levels</span><span class="p">[</span><span class="n">br</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">levels</span><span class="p">[</span><span class="n">br</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">levels</span><span class="p">[</span><span class="n">br</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>
                <span class="n">br</span> <span class="o">=</span> <span class="n">br</span><span class="o">+</span><span class="mi">1</span>
            
        <span class="c1"># read Literature values for dipole matrix elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_readLiteratureValues</span><span class="p">()</span>
        
        <span class="c1"># set correct executable for Numerov precompiled C/C++ module</span>
        <span class="c1"># for the given operating system</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numerovExec</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
            <span class="n">ostype</span> <span class="o">=</span> <span class="p">[</span><span class="n">platform</span><span class="o">.</span><span class="n">linux_distribution</span><span class="p">(),</span>\
                      <span class="n">platform</span><span class="o">.</span><span class="n">mac_ver</span><span class="p">(),</span>\
                      <span class="n">platform</span><span class="o">.</span><span class="n">win32_ver</span><span class="p">()]</span>
            <span class="n">ostypelett</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;linux&quot;</span><span class="p">,</span><span class="s2">&quot;mac&quot;</span><span class="p">,</span><span class="s2">&quot;win.exe&quot;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ostype</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">numerovExec</span> <span class="o">=</span> <span class="s2">&quot;nvwcpp_&quot;</span><span class="o">+</span><span class="n">ostypelett</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_databaseInit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataFolder</span><span class="p">,</span>\
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">precalculatedDB</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

<div class="viewcode-block" id="AlkaliAtom.getPressure"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.getPressure">[docs]</a>    <span class="k">def</span> <span class="nf">getPressure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">temperature</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Vapour pressure (in Pa) at given temperature</span>
<span class="sd">        </span>
<span class="sd">            Args:</span>
<span class="sd">                temperature (float): temperature in K</span>
<span class="sd">            Returns:</span>
<span class="sd">                float: vapour pressure in Pa</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span> <span class="s2">&quot;Error: getPressure to-be implement in child class (otherwise this</span><span class="se">\</span>
<span class="s2">                call is invalid for the specified atom&quot;</span>
        <span class="n">exit</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="AlkaliAtom.getNumberDensity"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.getNumberDensity">[docs]</a>    <span class="k">def</span> <span class="nf">getNumberDensity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">temperature</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Atom number density at given temperature</span>
<span class="sd">            </span>
<span class="sd">            See `calculation of basic properties example snippet`_.</span>
<span class="sd">            </span>
<span class="sd">            .. _`calculation of basic properties example snippet`:</span>
<span class="sd">                ./Rydberg_atoms_a_primer.html#General-atomic-properties</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                temperature (float): temperature in K</span>
<span class="sd">            Returns:</span>
<span class="sd">                float: atom concentration in :math:`1/m^3`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPressure</span><span class="p">(</span><span class="n">temperature</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">temperature</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="AlkaliAtom.getAverageInteratomicSpacing"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.getAverageInteratomicSpacing">[docs]</a>    <span class="k">def</span> <span class="nf">getAverageInteratomicSpacing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">temperature</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns average interatomic spacing in atomic vapour</span>
<span class="sd">            </span>
<span class="sd">            See `calculation of basic properties example snippet`_.</span>
<span class="sd">            </span>
<span class="sd">            .. _`calculation of basic properties example snippet`:</span>
<span class="sd">                ./Rydberg_atoms_a_primer.html#General-atomic-properties</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                temperature (float): temperature of the atomic vapour</span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                float: average interatomic spacing in m</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span>  <span class="p">(</span><span class="mf">5.</span><span class="o">/</span><span class="mf">9.</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">getNumberDensity</span><span class="p">(</span><span class="n">temperature</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="AlkaliAtom.corePotential"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.corePotential">[docs]</a>    <span class="k">def</span> <span class="nf">corePotential</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; core potential felt by valence electron</span>
<span class="sd">            </span>
<span class="sd">            For more details about derivation of model potential see </span>
<span class="sd">            Ref. [#marinescu]_.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                l (int): orbital angular momentum</span>
<span class="sd">                r (float): distance from the nucleus (in a.u.)</span>
<span class="sd">            Returns:</span>
<span class="sd">                float: core potential felt by valence electron (in a.u. ???)</span>
<span class="sd">                </span>
<span class="sd">            References:</span>
<span class="sd">                </span>
<span class="sd">                .. [#marinescu] M. Marinescu, H. R. Sadeghpour, and A. Dalgarno</span>
<span class="sd">                    PRA **49**, 982 (1994), https://doi.org/10.1103/PhysRevA.49.982</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">effectiveCharge</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">/</span><span class="n">r</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">alphaC</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">r</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">rc</span><span class="p">[</span><span class="n">l</span><span class="p">])</span><span class="o">**</span><span class="mi">6</span><span class="p">))</span> </div>
    
<div class="viewcode-block" id="AlkaliAtom.effectiveCharge"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.effectiveCharge">[docs]</a>    <span class="k">def</span> <span class="nf">effectiveCharge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; effective charge of the core felt by valence electron</span>
<span class="sd">            </span>
<span class="sd">            For more details about derivation of model potential see </span>
<span class="sd">            Ref. [#marinescu]_.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                l (int): orbital angular momentum</span>
<span class="sd">                r (float): distance from the nucleus (in a.u.)     </span>
<span class="sd">            Returns:     </span>
<span class="sd">                float: effective charge (in a.u.)</span>
<span class="sd">         &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">1.0</span><span class="o">+</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Z</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">a1</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">*</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a3</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">a4</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">*</span><span class="n">r</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">a2</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">*</span><span class="n">r</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="AlkaliAtom.potential"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.potential">[docs]</a>    <span class="k">def</span> <span class="nf">potential</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns total potential that electron feels</span>
<span class="sd">        </span>
<span class="sd">            Total potential = core potential + Spin-Orbit interaction </span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                l (int): orbital angular momentum</span>
<span class="sd">                s (float): spin angular momentum</span>
<span class="sd">                j (float): total angular momentum</span>
<span class="sd">                r (float): distance from the nucleus (in a.u.)    </span>
<span class="sd">            Returns:</span>
<span class="sd">                float: potential (in a.u.)   </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">l</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">corePotential</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">r</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mf">1.0</span><span class="p">)</span><span class="o">-</span><span class="n">l</span><span class="o">*</span><span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mf">1.0</span><span class="p">)</span><span class="o">-</span><span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="mf">2.0</span>   
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># act as if it is a Hydrogen atom</span>
            <span class="k">return</span> <span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="n">r</span></div>
    
<div class="viewcode-block" id="AlkaliAtom.radialWavefunction"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.radialWavefunction">[docs]</a>    <span class="k">def</span> <span class="nf">radialWavefunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">stateEnergy</span><span class="p">,</span><span class="n">innerLimit</span><span class="p">,</span><span class="n">outerLimit</span><span class="p">,</span><span class="n">step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Radial part of electron wavefunction</span>
<span class="sd">        </span>
<span class="sd">        Calculates radial function with Numerov (from outside towards the core).</span>
<span class="sd">        Note that wavefunction might not be calculated all the way to the requested </span>
<span class="sd">        `innerLimit` if the divergence occurs before. In that case third returned</span>
<span class="sd">        argument gives nonzero value, corresponding to the first index in the array</span>
<span class="sd">        for which wavefunction was calculated. For quick example see</span>
<span class="sd">        `Rydberg wavefunction calculation snippet`_.</span>
<span class="sd">        </span>
<span class="sd">        .. _`Rydberg wavefunction calculation snippet`:</span>
<span class="sd">            ./Rydberg_atoms_a_primer.html#Rydberg-atom-wavefunctions</span>
<span class="sd">        </span>
<span class="sd">        </span>

<span class="sd">        Args:</span>
<span class="sd">            l (int): orbital angular momentum</span>
<span class="sd">            s (float): spin angular momentum</span>
<span class="sd">            j (float): total angular momentum </span>
<span class="sd">            stateEnergy (float): state energy, relative to ionization threshold, </span>
<span class="sd">                should be given in atomic units (Hatree)</span>
<span class="sd">            innerLimit (float): inner limit at which wavefunction is requested</span>
<span class="sd">            outerLimit (float): outer limit at which wavefunction is requested</span>
<span class="sd">            step (flaot): radial step for integration mesh (a.u.)</span>
<span class="sd">        Returns:</span>
<span class="sd">            List[float], List[flaot], int:</span>
<span class="sd">                :math:`r`</span>
<span class="sd">                </span>
<span class="sd">                :math:`R(r)\cdot r`</span>
<span class="sd">                </span>
<span class="sd">                divergence index of array - smallest index</span>
<span class="sd">                of returned lists where there is no divergence (0 if divergence didn&#39;t occured).</span>
<span class="sd">                This is important for high :math:`l` wavefunction calculations.</span>
<span class="sd">        </span>
<span class="sd">        .. note::</span>
<span class="sd">            Radial wavefunction is not scaled to unity! This normalization</span>
<span class="sd">            condition means that we are using spherical harmonics which are</span>
<span class="sd">            normalized such that </span>
<span class="sd">            :math:`\\int \\mathrm{d}\\theta~\\mathrm{d}\\psi~Y(l,m_l)^* \\times \</span>
<span class="sd">            Y(l&#39;,m_{l&#39;})  =  \\delta (l,l&#39;) ~\\delta (m_l, m_{l&#39;})`.</span>
<span class="sd">            </span>
<span class="sd">        Note:</span>
<span class="sd">            Alternative calculation methods can be added here (potenatial </span>
<span class="sd">            package expansion).</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpp_numerov</span><span class="p">:</span>
            <span class="c1"># efficiant implementation in c++; wavefunctions are also memorized</span>
            <span class="n">today</span> <span class="o">=</span>  <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>

            <span class="n">timestamp</span> <span class="o">=</span> <span class="s1">&#39;{:</span><span class="si">%d</span><span class="s1">%S</span><span class="si">%f</span><span class="s1">}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">today</span><span class="p">)</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">__file__</span><span class="p">)),</span>\
                <span class="s2">&quot;temp&quot;</span><span class="p">,</span>\
                <span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_rwf_</span><span class="si">%.0f</span><span class="s2">_</span><span class="si">%.1f</span><span class="s2">_</span><span class="si">%.1f</span><span class="s2">_r&quot;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elementName</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="n">timestamp</span><span class="p">))</span>
           
            <span class="c1"># integration parameters</span>
            <span class="n">cmd1</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">%.15e</span><span class="s1"> </span><span class="si">%.15e</span><span class="s1"> </span><span class="si">%.15e</span><span class="s1"> </span><span class="si">%.15e</span><span class="s1"> </span><span class="si">%.15e</span><span class="s1"> &quot;</span><span class="si">%s</span><span class="s1">&quot; &#39;</span><span class="o">%</span> <span class="p">(</span><span class="n">innerLimit</span><span class="p">,</span><span class="n">outerLimit</span><span class="p">,</span>\
                                                          <span class="n">step</span><span class="p">,</span><span class="mf">0.01</span><span class="p">,</span><span class="mf">0.01</span><span class="p">,</span><span class="n">filename</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">):</span>
                <span class="n">cmd2</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%.1f</span><span class="s2"> </span><span class="si">%.1f</span><span class="s2"> </span><span class="si">%.15e</span><span class="s2"> </span><span class="si">%.15e</span><span class="s2"> </span><span class="si">%.15e</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%.15e</span><span class="s2"> </span><span class="si">%.15e</span><span class="s2"> </span><span class="si">%.15e</span><span class="s2"> </span><span class="si">%.15e</span><span class="s2"> </span><span class="si">%.15e</span><span class="s2">&quot;</span> <span class="o">%</span>\
                        <span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">stateEnergy</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">alphaC</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span>\
                        <span class="bp">self</span><span class="o">.</span><span class="n">a1</span><span class="p">[</span><span class="n">l</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">a2</span><span class="p">[</span><span class="n">l</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">a3</span><span class="p">[</span><span class="n">l</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">a4</span><span class="p">[</span><span class="n">l</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">rc</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cmd2</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%.1f</span><span class="s2"> </span><span class="si">%.1f</span><span class="s2"> </span><span class="si">%.15e</span><span class="s2"> </span><span class="si">%.15e</span><span class="s2"> </span><span class="si">%.15e</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%.15e</span><span class="s2"> </span><span class="si">%.15e</span><span class="s2"> </span><span class="si">%.15e</span><span class="s2"> </span><span class="si">%.15e</span><span class="s2"> </span><span class="si">%.15e</span><span class="s2">&quot;</span> <span class="o">%</span>\
                        <span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">stateEnergy</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">alphaC</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
            
            <span class="n">cmd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">__file__</span><span class="p">)),</span>\
                    <span class="bp">self</span><span class="o">.</span><span class="n">numerovExec</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="n">cmd1</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="n">cmd2</span><span class="p">)</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">shlex</span><span class="o">.</span><span class="n">split</span><span class="p">(</span> <span class="n">cmd</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\\\\</span><span class="s2">&quot;</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">proc</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> \
                         <span class="n">shell</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numerovExec</span> <span class="o">==</span> <span class="s2">&quot;nvwcpp_win.exe&quot;</span><span class="p">))</span>
            <span class="n">out</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
            <span class="n">exitcode</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">returncode</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">exitcode</span><span class="o">!=</span><span class="mi">0</span><span class="p">):</span>
                <span class="nb">print</span> <span class="s2">&quot;ERROR: C++ implementation of Numerov calculation of the </span><span class="se">\</span>
<span class="s2">                        wavefunction doesn&#39;t work. Error is:&quot;</span>
                <span class="nb">print</span> <span class="n">err</span>
                <span class="nb">print</span> <span class="s2">&quot;Try recompiling C++ code, or initialize atoms with cpp_numerov=False&quot;</span>
                <span class="nb">print</span> <span class="s2">&quot;e.g. atom = Rubidium(cpp_numerov=False)&quot;</span>
                <span class="nb">print</span> <span class="s2">&quot;NOTE: this will significantly slow down calculation of new </span><span class="se">\</span>
<span class="s2">                        dipole matrix elements. Recommended option is compilation</span><span class="se">\</span>
<span class="s2">                        of the C++ code. See documentation for more details&quot;</span>
                <span class="n">exit</span><span class="p">()</span>
            
            <span class="n">fileRoot</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s2">&quot;_rad.dat&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;f8&#39;</span><span class="p">),</span> <span class="n">count</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s2">&quot;_sol.dat&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;f8&#39;</span><span class="p">),</span> <span class="n">count</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">divergence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s2">&quot;_divergnece.dat&quot;</span><span class="p">,</span>\
                                     <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;i4&#39;</span><span class="p">),</span> <span class="n">count</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s2">&quot;_rad.dat&quot;</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s2">&quot;_sol.dat&quot;</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s2">&quot;_divergnece.dat&quot;</span><span class="p">)</span>

            <span class="n">btemp</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">divergence</span><span class="p">:]</span>
            <span class="n">suma</span> <span class="o">=</span> <span class="n">step</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">btemp</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">/</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">suma</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># full implementation in Python</span>
            <span class="k">def</span> <span class="nf">potential</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">stateEnergy</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">potential</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span><span class="o">-</span><span class="n">l</span><span class="o">*</span><span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">divergence</span> <span class="o">=</span> <span class="n">NumerovBack</span><span class="p">(</span><span class="n">innerLimit</span><span class="p">,</span><span class="n">outerLimit</span><span class="p">,</span><span class="n">potential</span><span class="p">,</span>\
                                         <span class="n">step</span><span class="p">,</span><span class="mf">0.01</span><span class="p">,</span><span class="mf">0.01</span><span class="p">)</span>
            
            <span class="n">btemp</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">divergence</span><span class="p">:]</span>
            <span class="n">suma</span> <span class="o">=</span> <span class="n">step</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">btemp</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">/</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">suma</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">divergence</span></div>
    
    <span class="k">def</span> <span class="nf">_parseLevelsFromNIST</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fileData</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Parses the level energies from file listing the NIST ASD data</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                fileData (str): path to the file containing NIST ASD data for the element</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fileData</span><span class="p">,</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="c1">#print line</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;[\[\]]&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="s2">&quot;\.\d*[spdfgh]&quot;</span>
            <span class="n">pattern2</span> <span class="o">=</span> <span class="s2">&quot;\|\s+\d*/&quot;</span>
            <span class="n">pattern3</span> <span class="o">=</span> <span class="s2">&quot;/\d* \|&quot;</span>
            <span class="n">pattern4</span> <span class="o">=</span> <span class="s2">&quot;\| *\d*\.\d* *\|&quot;</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span><span class="n">line</span><span class="p">)</span>
            <span class="c1">#print match.start()</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">ch</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()]</span>
                <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="s2">&quot;s&quot;</span><span class="p">:</span>
                    <span class="n">l</span><span class="o">=</span><span class="mi">0</span>
                <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span><span class="s2">&quot;p&quot;</span><span class="p">:</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s2">&quot;d&quot;</span><span class="p">:</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="mi">2</span>
                <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s2">&quot;f&quot;</span><span class="p">:</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="mi">3</span>
                <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s2">&quot;g&quot;</span><span class="p">:</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="mi">4</span>
                <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s2">&quot;h&quot;</span><span class="p">:</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="mi">5</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span> <span class="s2">&quot;Unidentified character in line:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">line</span>
                    <span class="n">exit</span><span class="p">()</span> 

            <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern2</span><span class="p">,</span><span class="n">line</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">match</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">br1</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">()</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span><span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern3</span><span class="p">,</span><span class="n">line</span><span class="p">)</span>
                <span class="n">br2</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern4</span><span class="p">,</span><span class="n">line</span><span class="p">)</span>
                <span class="n">energyValue</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="c1">#print n,&quot;,&quot;,l,&quot;,&quot;,br1/br2,&quot;,&quot;,energyValue</span>
                <span class="n">levels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">br1</span><span class="o">/</span><span class="n">br2</span><span class="p">,</span><span class="n">energyValue</span><span class="p">])</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">levels</span>

    <span class="k">def</span> <span class="nf">_addEnergy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">energyNIST</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Adding energy levels</span>
<span class="sd">            </span>
<span class="sd">            Accepts energy level relative to **ground state**, and</span>
<span class="sd">            saves energy levels, relative to the **ionization treshold**.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                energyNIST (float): energy relative to the nonexcited level (= 0 eV)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># </span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mf">0.5</span><span class="p">))</span><span class="o">&lt;</span><span class="mf">0.001</span><span class="p">:</span>
            <span class="c1"># j =l-1/2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sEnergy</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">energyNIST</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ionisationEnergy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># j = l+1/2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sEnergy</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">energyNIST</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ionisationEnergy</span>
    
<div class="viewcode-block" id="AlkaliAtom.getTransitionWavelength"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.getTransitionWavelength">[docs]</a>    <span class="k">def</span> <span class="nf">getTransitionWavelength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Calculated transition wavelength (in vacuum) in m.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                n1 (int): principal quantum number of the state **from** which we are going</span>
<span class="sd">                l1 (int): orbital angular momentum of the state **from** which we are going</span>
<span class="sd">                j1 (float): total angular momentum of the state **from** which we are going</span>
<span class="sd">                n2 (int): principal quantum number of the state **to** which we are going</span>
<span class="sd">                l2 (int): orbital angular momentum of the state **to** which we are going</span>
<span class="sd">                j2 (float): total angular momentum of the state **to** which we are going</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                float:</span>
<span class="sd">                    transition wavelength (in m). If the returned value is negative,</span>
<span class="sd">                    level from which we are going is **above** the level to which we are</span>
<span class="sd">                    going.    </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">h</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">j2</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">j1</span><span class="p">))</span><span class="o">*</span><span class="n">elemCharge</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="AlkaliAtom.getTransitionFrequency"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.getTransitionFrequency">[docs]</a>    <span class="k">def</span> <span class="nf">getTransitionFrequency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Calculated transition frequency in Hz</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                n1 (int): principal quantum number of the state **from** which we are going</span>
<span class="sd">                l1 (int): orbital angular momentum of the state **from** which we are going</span>
<span class="sd">                j1 (float): total angular momentum of the state **from** which we are going</span>
<span class="sd">                n2 (int): principal quantum number of the state **to** which we are going</span>
<span class="sd">                l2 (int): orbital angular momentum of the state **to** which we are going</span>
<span class="sd">                j2 (float): total angular momentum of the state **to** which we are going</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                float:</span>
<span class="sd">                    transition frequency (in Hz). If the returned value is negative,</span>
<span class="sd">                    level from which we are going is **above** the level to which we are</span>
<span class="sd">                    going.    </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">j2</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">j1</span><span class="p">))</span><span class="o">*</span><span class="n">elemCharge</span><span class="o">/</span><span class="n">h</span></div>
        
        
<div class="viewcode-block" id="AlkaliAtom.getEnergy"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.getEnergy">[docs]</a>    <span class="k">def</span> <span class="nf">getEnergy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Energy of the level relative to the ionisation level (in eV)</span>
<span class="sd">            </span>
<span class="sd">            If `preferQuantumDefects` =False (set during initialization) program </span>
<span class="sd">            will try use NIST energy value, if such exists, falling back to energy </span>
<span class="sd">            calculation with quantum defects if the measured value doesn&#39;t exist.</span>
<span class="sd">            For `preferQuantumDefects` =True, program will always calculate</span>
<span class="sd">            energies from quantum defects (useful for comparing quantum defect </span>
<span class="sd">            calculations with measured energy level values).</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                n (int): principal quantum number</span>
<span class="sd">                l (int): orbital angular momentum</span>
<span class="sd">                j (float): total angular momentum</span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                float: state energy (eV)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">l</span><span class="o">&gt;=</span><span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Requested energy for state l=</span><span class="si">%d</span><span class="s2"> &gt;= n=</span><span class="si">%d</span><span class="s2"> !&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
            
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mf">0.5</span><span class="p">))</span><span class="o">&lt;</span><span class="mf">0.001</span><span class="p">:</span>
            <span class="c1"># j = l-1/2</span>
            <span class="c1"># use NIST data ?</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">preferQuantumDefects</span> <span class="ow">or</span> 
                <span class="n">n</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">minQuantumDefectN</span><span class="p">)</span><span class="ow">and</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">NISTdataLevels</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sEnergy</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">l</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">8</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sEnergy</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">l</span><span class="p">]</span>
            <span class="c1"># else, use quantum defects</span>
            <span class="n">defect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getQuantumDefect</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">scaledRydbergConstant</span><span class="o">/</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="n">defect</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mf">0.5</span><span class="p">))</span><span class="o">&lt;</span><span class="mf">0.001</span><span class="p">:</span>
            <span class="c1"># j = l+1/2</span>
            <span class="c1"># use NIST data ?</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">preferQuantumDefects</span> <span class="ow">or</span> 
                <span class="n">n</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">minQuantumDefectN</span><span class="p">)</span><span class="ow">and</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">NISTdataLevels</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sEnergy</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">8</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sEnergy</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                
            <span class="c1"># else, use quantum defects</span>
            <span class="n">defect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getQuantumDefect</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">scaledRydbergConstant</span><span class="o">/</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="n">defect</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;j (=</span><span class="si">%.1f</span><span class="s2">) is not equal to l+1/2 nor l-1/2 (l=</span><span class="si">%d</span><span class="s2">)&quot;</span><span class="o">%</span>\
                             <span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">l</span><span class="p">))</span></div>

        
    
<div class="viewcode-block" id="AlkaliAtom.getQuantumDefect"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.getQuantumDefect">[docs]</a>    <span class="k">def</span> <span class="nf">getQuantumDefect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Quantum defect of the level.</span>
<span class="sd">            </span>
<span class="sd">            For an example, see `Rydberg energy levels example snippet`_.</span>
<span class="sd">            </span>
<span class="sd">            .. _`Rydberg energy levels example snippet`:</span>
<span class="sd">                ./Rydberg_atoms_a_primer.html#Rydberg-Atom-Energy-Levels</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                n (int): principal quantum number</span>
<span class="sd">                l (int): orbital angular momentum</span>
<span class="sd">                j (float): total angular momentum</span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                float: quantum defect   </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">defect</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mf">0.5</span><span class="p">))</span><span class="o">&lt;</span><span class="mf">0.001</span><span class="p">:</span>
                <span class="c1"># j = l-1/2</span>
                <span class="n">defect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantumDefect</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span>\
                    <span class="bp">self</span><span class="o">.</span><span class="n">quantumDefect</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">l</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">quantumDefect</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span>\
                    <span class="bp">self</span><span class="o">.</span><span class="n">quantumDefect</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">l</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">quantumDefect</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span>\
                    <span class="bp">self</span><span class="o">.</span><span class="n">quantumDefect</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">l</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">/</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">quantumDefect</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span><span class="o">+</span>\
                    <span class="bp">self</span><span class="o">.</span><span class="n">quantumDefect</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">l</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span><span class="o">/</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">quantumDefect</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">8</span><span class="p">)</span><span class="o">+</span>\
                    <span class="bp">self</span><span class="o">.</span><span class="n">quantumDefect</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">l</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span><span class="o">/</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">quantumDefect</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">10</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># j = l + 1/2</span>
                <span class="n">defect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantumDefect</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span>\
                    <span class="bp">self</span><span class="o">.</span><span class="n">quantumDefect</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">l</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">quantumDefect</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span>\
                    <span class="bp">self</span><span class="o">.</span><span class="n">quantumDefect</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">l</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">quantumDefect</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span>\
                    <span class="bp">self</span><span class="o">.</span><span class="n">quantumDefect</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">l</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">/</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">quantumDefect</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span><span class="o">+</span>\
                    <span class="bp">self</span><span class="o">.</span><span class="n">quantumDefect</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">l</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span><span class="o">/</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">quantumDefect</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">8</span><span class="p">)</span><span class="o">+</span>\
                    <span class="bp">self</span><span class="o">.</span><span class="n">quantumDefect</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">l</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span><span class="o">/</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">quantumDefect</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">10</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">defect</span> </div>
          
<div class="viewcode-block" id="AlkaliAtom.getRadialMatrixElement"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.getRadialMatrixElement">[docs]</a>    <span class="k">def</span> <span class="nf">getRadialMatrixElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">,</span><span class="n">useLiterature</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Radial part of the dipole matrix element</span>
<span class="sd">            </span>
<span class="sd">            Calculates :math:`\\int \\mathbf{d}r~R_{n_1,l_1,j_1}(r)\cdot \</span>
<span class="sd">                R_{n_1,l_1,j_1}(r) \cdot r^3`.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                n1 (int): principal quantum number of state 1</span>
<span class="sd">                l1 (int): orbital angular momentum of state 1</span>
<span class="sd">                j1 (float): total angular momentum of state 1</span>
<span class="sd">                n2 (int): principal quantum number of state 2</span>
<span class="sd">                l2 (int): orbital angular momentum of state 2</span>
<span class="sd">                j2 (float): total angular momentum of state 2</span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                float: dipole matrix element (:math:`a_0 e`).</span>
<span class="sd">        &quot;&quot;&quot;</span> 
        <span class="n">dl</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">l1</span><span class="o">-</span><span class="n">l2</span><span class="p">)</span>
        <span class="n">dj</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">j2</span><span class="o">-</span><span class="n">j2</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">dl</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dj</span><span class="o">&lt;</span><span class="mf">1.1</span><span class="p">)):</span>
            <span class="k">return</span> <span class="mi">0</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">j1</span><span class="p">)</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">j2</span><span class="p">)):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">n1</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="n">n2</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">temp</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">l1</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">l2</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">temp</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">j1</span>
            <span class="n">j1</span> <span class="o">=</span> <span class="n">j2</span>
            <span class="n">j2</span> <span class="o">=</span> <span class="n">temp</span>
        
        <span class="k">if</span> <span class="n">useLiterature</span><span class="p">:</span>
            <span class="c1"># is there literature value for this DME? If there is, use the best one (smalles error)</span>
            <span class="n">j1_x2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">j1</span>
            <span class="n">j2_x2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">j2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;SELECT dme FROM literatureDME WHERE</span>
<span class="s1">             n1= ? AND l1 = ? AND j1_x2 = ? AND </span>
<span class="s1">             n2 = ? AND l2 = ? AND j2_x2 = ? </span>
<span class="s1">             ORDER BY errorEstimate ASC&#39;&#39;&#39;</span><span class="p">,(</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1_x2</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2_x2</span><span class="p">))</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">answer</span><span class="p">):</span>
                <span class="c1"># we did found literature value</span>
                <span class="k">return</span> <span class="n">answer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        
        <span class="c1"># was this calculated before? If it was, retrieve from memory</span>
        <span class="n">j1_x2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">j1</span>
        <span class="n">j2_x2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">j2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;SELECT dme FROM dipoleME WHERE</span>
<span class="s1">         n1= ? AND l1 = ? AND j1_x2 = ? AND </span>
<span class="s1">         n2 = ? AND l2 = ? AND j2_x2 = ?&#39;&#39;&#39;</span><span class="p">,(</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1_x2</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2_x2</span><span class="p">))</span>
        <span class="n">dme</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dme</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">dme</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">step</span> <span class="o">=</span> <span class="mf">0.01</span>    
        <span class="n">a1</span><span class="p">,</span><span class="n">b1</span><span class="p">,</span><span class="n">start1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radialWavefunction</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span>\
                                               <span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">j1</span><span class="p">)</span><span class="o">/</span><span class="mf">27.211</span><span class="p">,</span>\
                                               <span class="bp">self</span><span class="o">.</span><span class="n">alphaC</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mf">3.0</span><span class="p">),</span>\
                                                <span class="mf">2.0</span><span class="o">*</span><span class="n">n1</span><span class="o">*</span><span class="p">(</span><span class="n">n1</span><span class="o">+</span><span class="mf">15.0</span><span class="p">),</span> <span class="n">step</span><span class="p">)</span>
        <span class="n">a2</span><span class="p">,</span><span class="n">b2</span><span class="p">,</span><span class="n">start2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radialWavefunction</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="n">j2</span><span class="p">,</span>\
                                               <span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">j2</span><span class="p">)</span><span class="o">/</span><span class="mf">27.211</span><span class="p">,</span>\
                                               <span class="bp">self</span><span class="o">.</span><span class="n">alphaC</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mf">3.0</span><span class="p">),</span>\
                                                <span class="mf">2.0</span><span class="o">*</span><span class="n">n2</span><span class="o">*</span><span class="p">(</span><span class="n">n2</span><span class="o">+</span><span class="mf">15.0</span><span class="p">),</span> <span class="n">step</span><span class="p">)</span>
        
        <span class="n">br</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">start1</span><span class="p">,</span><span class="n">start2</span><span class="p">)</span>
        <span class="n">upTo</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a1</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">a2</span><span class="p">))</span>
        
        <span class="n">b1</span> <span class="o">=</span> <span class="n">b1</span><span class="p">[</span><span class="n">br</span><span class="p">:</span><span class="n">upTo</span><span class="p">]</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="n">b2</span><span class="p">[</span><span class="n">br</span><span class="p">:</span><span class="n">upTo</span><span class="p">]</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="n">a1</span><span class="p">[</span><span class="n">br</span><span class="p">:</span><span class="n">upTo</span><span class="p">]</span>
        
        <span class="n">dipoleElement</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span><span class="n">b2</span><span class="p">),</span><span class="n">a1</span><span class="o">*</span><span class="n">step</span><span class="p">))</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39; INSERT INTO dipoleME VALUES (?,?,?, ?,?,?, ?)&#39;&#39;&#39;</span><span class="p">,</span>\
                       <span class="p">[</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1_x2</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2_x2</span><span class="p">,</span> <span class="n">dipoleElement</span><span class="p">]</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

        
        <span class="c1"># with dipoleMatrixElement as numpy array</span>
        <span class="c1">#if (len(self.dipoleMatrixElement)&gt;0):</span>
        <span class="c1">#    self.dipoleMatrixElement = np.concatenate( (self.dipoleMatrixElement,\</span>
        <span class="c1">#                                                np.array([[n1,l1,j1,n2,\</span>
        <span class="c1">#                                                           l2,j2,\</span>
        <span class="c1">#                                                           dipoleElement]])),\</span>
        <span class="c1">#                                              axis=0)</span>
        <span class="c1">#else:</span>
        <span class="c1">#    self.dipoleMatrixElement =  np.array([[n1,l1,j1,n2,l2,j2,dipoleElement]])</span>
        
        <span class="k">return</span> <span class="n">dipoleElement</span></div>


    
<div class="viewcode-block" id="AlkaliAtom.getQuadrupoleMatrixElement"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.getQuadrupoleMatrixElement">[docs]</a>    <span class="k">def</span> <span class="nf">getQuadrupoleMatrixElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Radial part of the quadrupole matrix element</span>
<span class="sd">            </span>
<span class="sd">            Calculates :math:`\\int \\mathbf{d}r~R_{n_1,l_1,j_1}(r)\cdot \</span>
<span class="sd">            R_{n_1,l_1,j_1}(r) \cdot r^4`.</span>
<span class="sd">            See `Quadrupole calculation example snippet`_  .  </span>
<span class="sd">            </span>
<span class="sd">            .. _`Quadrupole calculation example snippet`:</span>
<span class="sd">                ./Rydberg_atoms_a_primer.html#Quadrupole-matrix-elements</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                n1 (int): principal quantum number of state 1</span>
<span class="sd">                l1 (int): orbital angular momentum of state 1</span>
<span class="sd">                j1 (float): total angular momentum of state 1</span>
<span class="sd">                n2 (int): principal quantum number of state 2</span>
<span class="sd">                l2 (int): orbital angular momentum of state 2</span>
<span class="sd">                j2 (float): total angular momentum of state 2</span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                float: quadrupole matrix element (:math:`a_0^2 e`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">dl</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">l1</span><span class="o">-</span><span class="n">l2</span><span class="p">)</span>
        <span class="n">dj</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">j1</span><span class="o">-</span><span class="n">j2</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">dl</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">dl</span><span class="o">==</span><span class="mi">2</span> <span class="ow">or</span> <span class="n">dl</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span><span class="ow">and</span> <span class="p">(</span><span class="n">dj</span><span class="o">&lt;</span><span class="mf">2.1</span><span class="p">)):</span>
            <span class="k">return</span> <span class="mi">0</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">j1</span><span class="p">)</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">j2</span><span class="p">)):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">n1</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="n">n2</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">temp</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">l1</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">l2</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">temp</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">j1</span>
            <span class="n">j1</span> <span class="o">=</span> <span class="n">j2</span>
            <span class="n">j2</span> <span class="o">=</span> <span class="n">temp</span>
        
        <span class="c1"># was this calculated before? If yes, retrieve from memory.</span>
        <span class="n">j1_x2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">j1</span>
        <span class="n">j2_x2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">j2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;SELECT qme FROM quadrupoleME WHERE</span>
<span class="s1">         n1= ? AND l1 = ? AND j1_x2 = ? AND </span>
<span class="s1">         n2 = ? AND l2 = ? AND j2_x2 = ?&#39;&#39;&#39;</span><span class="p">,(</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1_x2</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2_x2</span><span class="p">))</span>
        <span class="n">qme</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">qme</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">qme</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># if it wasn&#39;t, calculate now</span>
        
        <span class="n">step</span> <span class="o">=</span> <span class="mf">0.01</span>    
        <span class="n">a1</span><span class="p">,</span><span class="n">b1</span><span class="p">,</span><span class="n">start1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radialWavefunction</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span>\
                                               <span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">j1</span><span class="p">)</span><span class="o">/</span><span class="mf">27.211</span><span class="p">,</span>\
                                               <span class="bp">self</span><span class="o">.</span><span class="n">alphaC</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mf">3.0</span><span class="p">),</span> \
                                               <span class="mf">2.0</span><span class="o">*</span><span class="n">n1</span><span class="o">*</span><span class="p">(</span><span class="n">n1</span><span class="o">+</span><span class="mf">15.0</span><span class="p">),</span> <span class="n">step</span><span class="p">)</span>
        <span class="n">a2</span><span class="p">,</span><span class="n">b2</span><span class="p">,</span><span class="n">start2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radialWavefunction</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="n">j2</span><span class="p">,</span>\
                                               <span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">j2</span><span class="p">)</span><span class="o">/</span><span class="mf">27.211</span><span class="p">,</span>\
                                               <span class="bp">self</span><span class="o">.</span><span class="n">alphaC</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mf">3.0</span><span class="p">),</span> \
                                               <span class="mf">2.0</span><span class="o">*</span><span class="n">n2</span><span class="o">*</span><span class="p">(</span><span class="n">n2</span><span class="o">+</span><span class="mf">15.0</span><span class="p">),</span> <span class="n">step</span><span class="p">)</span>
        

        <span class="n">br</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">start1</span><span class="p">,</span><span class="n">start2</span><span class="p">)</span>
        <span class="c1"># START of the new way of summing</span>
        <span class="n">upTo</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a1</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">a2</span><span class="p">))</span>
        
        <span class="n">b1</span> <span class="o">=</span> <span class="n">b1</span><span class="p">[</span><span class="n">br</span><span class="p">:</span><span class="n">upTo</span><span class="p">]</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="n">b2</span><span class="p">[</span><span class="n">br</span><span class="p">:</span><span class="n">upTo</span><span class="p">]</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="n">a1</span><span class="p">[</span><span class="n">br</span><span class="p">:</span><span class="n">upTo</span><span class="p">]</span>
        
        <span class="n">quadrupoleElement</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span><span class="n">b2</span><span class="p">),</span>\
                                               <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span><span class="n">a1</span><span class="p">)</span><span class="o">*</span><span class="n">step</span><span class="p">))</span>    

        
        
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39; INSERT INTO quadrupoleME VALUES (?,?,?, ?,?,?, ?)&#39;&#39;&#39;</span><span class="p">,</span>\
                       <span class="p">[</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1_x2</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2_x2</span><span class="p">,</span> <span class="n">quadrupoleElement</span><span class="p">]</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
        
        <span class="c1">#if (len(self.quadrupoleMatrixElement)&gt;0):</span>
        <span class="c1">#    self.quadrupoleMatrixElement = np.concatenate((self.quadrupoleMatrixElement,</span>
        <span class="c1">#                                                   np.array([[n1,l1,j1,\</span>
        <span class="c1">#                                                              n2,l2,j2,\</span>
        <span class="c1">#                                                    quadrupoleElement]])),\</span>
        <span class="c1">#                                                  axis=0)</span>
        <span class="c1">#else:</span>
        <span class="c1">#    self.quadrupoleMatrixElement =  np.array([[n1,l1,j1,n2,l2,j2,\</span>
        <span class="c1">#                                               quadrupoleElement]])</span>
        
        <span class="k">return</span> <span class="n">quadrupoleElement</span>  </div>
        
    
<div class="viewcode-block" id="AlkaliAtom.getReducedMatrixElementJ_asymmetric"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.getReducedMatrixElementJ_asymmetric">[docs]</a>    <span class="k">def</span> <span class="nf">getReducedMatrixElementJ_asymmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Reduced matrix element in :math:`J` basis, defined in asymmetric</span>
<span class="sd">            notation.</span>
<span class="sd">            </span>
<span class="sd">            Note that notation for symmetric and asymmetricly defined</span>
<span class="sd">            reduced matrix element is not consistent in the literature. For </span>
<span class="sd">            example, notation is used e.g. in Steck [1]_ is precisely the oposite.</span>
<span class="sd">                       </span>
<span class="sd">            Note:</span>
<span class="sd">                Note that this notation is asymmetric: :math:`( j||e r \</span>
<span class="sd">                ||j&#39; ) \\neq ( j&#39;||e r ||j )`.</span>
<span class="sd">                Relation between the two notation is :math:`\\langle j||er||j&#39;\\rangle=\</span>
<span class="sd">                \\sqrt{2j+1} ( j ||er ||j&#39;)`.</span>
<span class="sd">                This function always returns value for transition from </span>
<span class="sd">                lower to higher energy state, independent of the order of states </span>
<span class="sd">                entered in the function call.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                n1 (int): principal quantum number of state 1</span>
<span class="sd">                l1 (int): orbital angular momentum of state 1</span>
<span class="sd">                j1 (float): total angular momentum of state 1</span>
<span class="sd">                n2 (int): principal quantum number of state 2</span>
<span class="sd">                l2 (int): orbital angular momentum of state 2</span>
<span class="sd">                j2 (float): total angular momentum of state 2</span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                float:</span>
<span class="sd">                    reduced dipole matrix element in Steck notation </span>
<span class="sd">                    :math:`\\langle j || er || j&#39; \\rangle` (:math:`a_0 e`).</span>
<span class="sd">        </span>
<span class="sd">            .. [1] Daniel A. Steck, &quot;Cesium D Line Data,&quot; (revision 2.0.1, 2 May 2008).</span>
<span class="sd">                http://steck.us/alkalidata </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># </span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getTransitionFrequency</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">j1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">j2</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">n2</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">n1</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="n">temp</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">l1</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">l2</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">temp</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">j1</span>
            <span class="n">j1</span> <span class="o">=</span> <span class="n">j2</span>
            <span class="n">j2</span> <span class="o">=</span> <span class="n">temp</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">((</span><span class="n">l1</span><span class="o">-</span><span class="n">l2</span><span class="o">+</span><span class="mf">1.0</span><span class="p">))</span><span class="o">/</span><span class="mf">2.0</span><span class="o">+</span><span class="n">j2</span><span class="o">+</span><span class="n">l1</span><span class="o">+</span><span class="mf">1.0</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="nb">int</span><span class="p">((</span><span class="n">l2</span><span class="o">+</span><span class="n">l1</span><span class="o">+</span><span class="mf">3.</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="o">+</span><span class="mf">0.5</span><span class="o">+</span><span class="n">j2</span><span class="p">))</span><span class="o">*</span>\
                <span class="n">sqrt</span><span class="p">((</span><span class="mf">2.0</span><span class="o">*</span><span class="n">j2</span><span class="o">+</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">l1</span><span class="o">+</span><span class="mf">1.0</span><span class="p">))</span><span class="o">*</span>\
                <span class="n">Wigner6j</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">j2</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span>\
                <span class="n">sqrt</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">l2</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">l1</span><span class="o">+</span><span class="mf">1.0</span><span class="p">))</span><span class="o">*</span>\
                <span class="bp">self</span><span class="o">.</span><span class="n">getRadialMatrixElement</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">j1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">j2</span><span class="p">)</span></div>

<div class="viewcode-block" id="AlkaliAtom.getReducedMatrixElementL"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.getReducedMatrixElementL">[docs]</a>    <span class="k">def</span> <span class="nf">getReducedMatrixElementL</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Reduced matrix element in :math:`L` basis (symmetric notation)</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                n1 (int): principal quantum number of state 1</span>
<span class="sd">                l1 (int): orbital angular momentum of state 1</span>
<span class="sd">                j1 (float): total angular momentum of state 1</span>
<span class="sd">                n2 (int): principal quantum number of state 2</span>
<span class="sd">                l2 (int): orbital angular momentum of state 2</span>
<span class="sd">                j2 (float): total angular momentum of state 2</span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                float:</span>
<span class="sd">                    reduced dipole matrix element in :math:`L` basis </span>
<span class="sd">                    :math:`( l || er || l&#39; )` (:math:`a_0 e`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">l1</span><span class="o">*</span><span class="n">sqrt</span><span class="p">((</span><span class="mf">2.0</span><span class="o">*</span><span class="n">l1</span><span class="o">+</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">l2</span><span class="o">+</span><span class="mf">1.0</span><span class="p">))</span><span class="o">*</span>\
                <span class="n">Wigner3j</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span>\
                <span class="bp">self</span><span class="o">.</span><span class="n">getRadialMatrixElement</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">j1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">j2</span><span class="p">)</span></div>

<div class="viewcode-block" id="AlkaliAtom.getReducedMatrixElementJ"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.getReducedMatrixElementJ">[docs]</a>    <span class="k">def</span> <span class="nf">getReducedMatrixElementJ</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Reduced matrix element in :math:`J` basis (symmetric notation)</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                n1 (int): principal quantum number of state 1</span>
<span class="sd">                l1 (int): orbital angular momentum of state 1</span>
<span class="sd">                j1 (float): total angular momentum of state 1</span>
<span class="sd">                n2 (int): principal quantum number of state 2</span>
<span class="sd">                l2 (int): orbital angular momentum of state 2</span>
<span class="sd">                j2 (float): total angular momentum of state 2</span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                float:</span>
<span class="sd">                    reduced dipole matrix element in :math:`J` basis </span>
<span class="sd">                    :math:`\\langle j || er || j&#39; \\rangle` (:math:`a_0 e`).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">l1</span><span class="o">+</span><span class="mf">0.5</span><span class="o">+</span><span class="n">j2</span><span class="o">+</span><span class="mf">1.</span><span class="p">))</span><span class="o">*</span><span class="n">sqrt</span><span class="p">((</span><span class="mf">2.</span><span class="o">*</span><span class="n">j1</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">j2</span><span class="o">+</span><span class="mf">1.</span><span class="p">))</span><span class="o">*</span>\
                <span class="n">Wigner6j</span><span class="p">(</span><span class="n">j1</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">j2</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">l1</span><span class="p">)</span><span class="o">*</span>\
                <span class="bp">self</span><span class="o">.</span><span class="n">getReducedMatrixElementL</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">)</span></div>

         
<div class="viewcode-block" id="AlkaliAtom.getDipoleMatrixElement"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.getDipoleMatrixElement">[docs]</a>    <span class="k">def</span> <span class="nf">getDipoleMatrixElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">mj1</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">,</span><span class="n">mj2</span><span class="p">,</span><span class="n">q</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Reduced dipole matrix element </span>
<span class="sd">            :math:`\\langle n_1 l_1 j_1 m_{j_1} |e\\mathbf{r}|n_2 l_2 j_2 m_{j_2}\\rangle`</span>
<span class="sd">            in units of :math:`a_0 e`</span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                float: dipole matrix element( :math:`a_0 e`)</span>
<span class="sd">            </span>
<span class="sd">            Example:</span>
<span class="sd">            </span>
<span class="sd">                For example, calculation of :math:`5 S_{1/2}m_j=-\\frac{1}{2} \\rightarrow  5 P_{3/2}m_j=-\\frac{3}{2}`</span>
<span class="sd">                transition dipole matrix element for laser driving :math:`\sigma^-`</span>
<span class="sd">                transition::</span>
<span class="sd">                    </span>
<span class="sd">                    from arc import *</span>
<span class="sd">                    atom = Rubidium()</span>
<span class="sd">                    # transition 5 S_{1/2} m_j=-0.5 -&gt; 5 P_{3/2} m_j=-1.5 for laser </span>
<span class="sd">                    # driving sigma- transition</span>
<span class="sd">                    print atom.getDipoleMatrixElement(5,0,0.5,-0.5,5,1,1.5,-1.5,-1)</span>
<span class="sd">                    </span>
<span class="sd">                    </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#q = -mj2+mj1</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">&gt;</span><span class="mf">1.1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">j1</span><span class="o">-</span><span class="n">mj1</span><span class="p">))</span><span class="o">*</span>\
                <span class="n">Wigner3j</span><span class="p">(</span><span class="n">j1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j2</span><span class="p">,</span> <span class="o">-</span><span class="n">mj1</span><span class="p">,</span> <span class="o">-</span><span class="n">q</span><span class="p">,</span> <span class="n">mj2</span><span class="p">)</span><span class="o">*</span>\
                <span class="bp">self</span><span class="o">.</span><span class="n">getReducedMatrixElementJ</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">)</span> </div>
    
<div class="viewcode-block" id="AlkaliAtom.getRabiFrequency"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.getRabiFrequency">[docs]</a>    <span class="k">def</span> <span class="nf">getRabiFrequency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">mj1</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">laserPower</span><span class="p">,</span><span class="n">laserWaist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns a Rabi frequency for resonant excitation</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                n1,l1,j1,mj1 : state from which we are driving transition</span>
<span class="sd">                n2,l2,j2 : state to which we are driving transition</span>
<span class="sd">                q : laser polarization (-1,0,1 correspond to :math:`\sigma^-`,</span>
<span class="sd">                    :math:`\pi` and :math:`\sigma^+` respectively)</span>
<span class="sd">                laserPower : laser power in units of W</span>
<span class="sd">                laserWaist : laser :math:`1/e^2` waist (radius) in units of m</span>
<span class="sd">                </span>
<span class="sd">            </span>
<span class="sd">            Returns: </span>
<span class="sd">                float:</span>
<span class="sd">                    Frequency in rad :math:`^{-1}`. If you want frequency in Hz,</span>
<span class="sd">                    divide by returned value by :math:`2\pi`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mj2</span> <span class="o">=</span> <span class="n">mj1</span><span class="o">+</span><span class="n">q</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">mj2</span><span class="p">)</span><span class="o">-</span><span class="mf">0.1</span><span class="o">&gt;</span><span class="n">j2</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">dipole</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDipoleMatrixElement</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">mj1</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">,</span><span class="n">mj2</span><span class="p">,</span><span class="n">q</span><span class="p">)</span><span class="o">*</span>\
                <span class="n">elemCharge</span><span class="o">*</span><span class="n">physical_constants</span><span class="p">[</span><span class="s2">&quot;Bohr radius&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">maxIntensity</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">laserPower</span><span class="o">/</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span> <span class="n">laserWaist</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">electricField</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">maxIntensity</span><span class="o">/</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">epsilon_0</span><span class="p">))</span> 
        <span class="n">freq</span> <span class="o">=</span> <span class="n">electricField</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">dipole</span><span class="p">)</span><span class="o">/</span><span class="n">hbar</span> 
        <span class="k">return</span> <span class="n">freq</span></div>
    
<div class="viewcode-block" id="AlkaliAtom.getC6term"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.getC6term">[docs]</a>    <span class="k">def</span> <span class="nf">getC6term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            C6 interaction term for the given two pair-states</span>
<span class="sd">            </span>
<span class="sd">            Calculates :math:`C_6` intaraction term for :math:`|n,l,j,n,l,j\\rangle\</span>
<span class="sd">            \\leftrightarrow |n_1,l_1,j_1,n_2,l_2,j_2\\rangle`. For details</span>
<span class="sd">            of calculation see Ref. [#c6r1]_.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                n (int): principal quantum number</span>
<span class="sd">                l (int): orbital angular momenutum</span>
<span class="sd">                j (float): total angular momentum</span>
<span class="sd">                n1 (int): principal quantum number </span>
<span class="sd">                l1 (int): orbital angular momentum </span>
<span class="sd">                j1 (float): total angular momentum </span>
<span class="sd">                n2 (int): principal quantum number </span>
<span class="sd">                l2 (int): orbital angular momentum </span>
<span class="sd">                j2 (float): total angular momentum </span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                float:  :math:`C_6 = \\frac{1}{4\\pi\\varepsilon_0} \</span>
<span class="sd">                    \\frac{|\\langle n,l,j |er|n_1,l_1,j_1\\rangle|^2|\</span>
<span class="sd">                    \\langle n,l,j |er|n_2,l_2,j_2\\rangle|^2}\</span>
<span class="sd">                    {E(n_1,l_1,j_2,n_2,j_2,j_2)-E(n,l,j,n,l,j)}`</span>
<span class="sd">                (:math:`h` Hz m :math:`{}^6`).</span>
<span class="sd">            </span>
<span class="sd">            Example:</span>
<span class="sd">                We can reproduce values from Ref. [#c6r1]_ for C3 coupling</span>
<span class="sd">                to particular channels. Taking for example channels described</span>
<span class="sd">                by the Eq. (50a-c) we can get the values::</span>
<span class="sd">                    </span>
<span class="sd">                    from arc import *</span>
<span class="sd">                    </span>
<span class="sd">                    channels = [[70,0,0.5, 70, 1,1.5, 69,1, 1.5],\\</span>
<span class="sd">                                [70,0,0.5, 70, 1,1.5, 69,1, 0.5],\\</span>
<span class="sd">                                [70,0,0.5, 69, 1,1.5, 70,1, 0.5],\\</span>
<span class="sd">                                [70,0,0.5, 70, 1,0.5, 69,1, 0.5]]</span>
<span class="sd">                    </span>
<span class="sd">                    print &quot; = = = Caesium = = = &quot;</span>
<span class="sd">                    atom = Caesium()</span>
<span class="sd">                    for channel in channels:</span>
<span class="sd">                        print &quot;%.0f  GHz (mu m)^6&quot; % ( atom.getC6term(*channel)/h*1.e27 )</span>
<span class="sd">                    </span>
<span class="sd">                    print &quot;\\n = = = Rubidium  = = =&quot;</span>
<span class="sd">                    atom = Rubidium()</span>
<span class="sd">                    for channel in channels:</span>
<span class="sd">                        print &quot;%.0f  GHz (mu m)^6&quot; % ( atom.getC6term(*channel)/h*1.e27 )</span>
<span class="sd">                    </span>
<span class="sd">                Returns::</span>
<span class="sd">                </span>
<span class="sd">                     = = = Caesium = = = </span>
<span class="sd">                    722  GHz (mu m)^6</span>
<span class="sd">                    316  GHz (mu m)^6</span>
<span class="sd">                    383  GHz (mu m)^6</span>
<span class="sd">                    228  GHz (mu m)^6</span>
<span class="sd">                    </span>
<span class="sd">                     = = = Rubidium  = = =</span>
<span class="sd">                    799  GHz (mu m)^6</span>
<span class="sd">                    543  GHz (mu m)^6</span>
<span class="sd">                    589  GHz (mu m)^6</span>
<span class="sd">                    437  GHz (mu m)^6</span>
<span class="sd">                </span>
<span class="sd">                which is in good agreement with the values cited in the Ref. [#c6r1]_.</span>
<span class="sd">                Small discrepancies for Caesium originate from slightly different</span>
<span class="sd">                quantum defects used in calculations.</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">            References:</span>
<span class="sd">                .. [#c6r1] T. G. Walker, M. Saffman, PRA **77**, 032723 (2008)</span>
<span class="sd">                    https://doi.org/10.1103/PhysRevA.77.032723</span>
<span class="sd">                    </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRadialMatrixElement</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">)</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRadialMatrixElement</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">)</span>
        <span class="n">d1d2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">epsilon_0</span><span class="p">)</span><span class="o">*</span><span class="n">d1</span><span class="o">*</span><span class="n">d2</span><span class="o">*</span><span class="n">elemCharge</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span>\
                <span class="p">(</span><span class="n">physical_constants</span><span class="p">[</span><span class="s2">&quot;Bohr radius&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">d1d2</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="n">elemCharge</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">)</span><span class="o">+</span>\
                                     <span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">)</span><span class="o">-</span>\
                                     <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)))</span></div>

<div class="viewcode-block" id="AlkaliAtom.getC3term"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.getC3term">[docs]</a>    <span class="k">def</span> <span class="nf">getC3term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            C3 interaction term for the given two pair-states</span>
<span class="sd">            </span>
<span class="sd">            Calculates :math:`C_3` intaraction term for :math:`|n,l,j,n,l,j\\rangle \</span>
<span class="sd">                 \\leftrightarrow |n_1,l_1,j_1,n_2,l_2,j_2\\rangle`</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                n (int): principal quantum number</span>
<span class="sd">                l (int): orbital angular momenutum</span>
<span class="sd">                j (float): total angular momentum</span>
<span class="sd">                n1 (int): principal quantum number </span>
<span class="sd">                l1 (int): orbital angular momentum </span>
<span class="sd">                j1 (float): total angular momentum </span>
<span class="sd">                n2 (int): principal quantum number </span>
<span class="sd">                l2 (int): orbital angular momentum </span>
<span class="sd">                j2 (float): total angular momentum </span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                float:  :math:`C_3 = \\frac{\\langle n,l,j |er|n_1,l_1,j_1\\rangle \</span>
<span class="sd">                    \\langle n,l,j |er|n_2,l_2,j_2\\rangle}{4\\pi\\varepsilon_0}`</span>
<span class="sd">                (:math:`h` Hz m :math:`{}^3`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRadialMatrixElement</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">)</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRadialMatrixElement</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">)</span>
        <span class="n">d1d2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">epsilon_0</span><span class="p">)</span><span class="o">*</span><span class="n">d1</span><span class="o">*</span><span class="n">d2</span><span class="o">*</span><span class="n">elemCharge</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span>\
                <span class="p">(</span><span class="n">physical_constants</span><span class="p">[</span><span class="s2">&quot;Bohr radius&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">return</span> <span class="n">d1d2</span></div>

<div class="viewcode-block" id="AlkaliAtom.getEnergyDefect"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.getEnergyDefect">[docs]</a>    <span class="k">def</span> <span class="nf">getEnergyDefect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Energy defect for the given two pair-states (one of the state has </span>
<span class="sd">            two atoms in the same state)</span>
<span class="sd">            </span>
<span class="sd">            Energy difference between the states :math:`E(n,l,j,n,l,j) - \</span>
<span class="sd">            E(n_1,l_1,j_1,n_2,l_2,j_2)`</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                n (int): principal quantum number</span>
<span class="sd">                l (int): orbital angular momenutum</span>
<span class="sd">                j (float): total angular momentum</span>
<span class="sd">                n1 (int): principal quantum number </span>
<span class="sd">                l1 (int): orbital angular momentum </span>
<span class="sd">                j1 (float): total angular momentum </span>
<span class="sd">                n2 (int): principal quantum number </span>
<span class="sd">                l2 (int): orbital angular momentum </span>
<span class="sd">                j2 (float): total angular momentum </span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                float:  energy defect (SI units: J)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">elemCharge</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">)</span><span class="o">-</span>\
                           <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">))</span></div>
    
<div class="viewcode-block" id="AlkaliAtom.getEnergyDefect2"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.getEnergyDefect2">[docs]</a>    <span class="k">def</span> <span class="nf">getEnergyDefect2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">nn</span><span class="p">,</span><span class="n">ll</span><span class="p">,</span><span class="n">jj</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Energy defect for the given two pair-states</span>
<span class="sd">            </span>
<span class="sd">            Energy difference between the states :math:`E(n,l,j,nn,ll,jj) - \</span>
<span class="sd">            E(n_1,l_1,j_1,n_2,l_2,j_2)`</span>
<span class="sd">            </span>
<span class="sd">            See `pair-state energy defects example snippet`_.</span>
<span class="sd">            </span>
<span class="sd">            .. _`pair-state energy defects example snippet`:</span>
<span class="sd">                ./Rydberg_atoms_a_primer.html#Rydberg-atom-interactions</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                n (int): principal quantum number</span>
<span class="sd">                l (int): orbital angular momenutum</span>
<span class="sd">                j (float): total angular momentum</span>
<span class="sd">                nn (int): principal quantum number</span>
<span class="sd">                ll (int): orbital angular momenutum</span>
<span class="sd">                jj (float): total angular momentum                </span>
<span class="sd">                n1 (int): principal quantum number </span>
<span class="sd">                l1 (int): orbital angular momentum </span>
<span class="sd">                j1 (float): total angular momentum </span>
<span class="sd">                n2 (int): principal quantum number </span>
<span class="sd">                l2 (int): orbital angular momentum </span>
<span class="sd">                j2 (float): total angular momentum </span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                float:  energy defect (SI units: J)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">elemCharge</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">)</span><span class="o">-</span>\
                           <span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span><span class="n">ll</span><span class="p">,</span><span class="n">jj</span><span class="p">))</span></div>
    
<div class="viewcode-block" id="AlkaliAtom.updateDipoleMatrixElementsFile"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.updateDipoleMatrixElementsFile">[docs]</a>    <span class="k">def</span> <span class="nf">updateDipoleMatrixElementsFile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Updates the file with pre-calculated dipole matrix elements.</span>
<span class="sd">            </span>
<span class="sd">            This function will add the the file all the elements that have been </span>
<span class="sd">            calculated in the previous run, allowing quick access to them in the </span>
<span class="sd">            future calculations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># obtain dipole matrix elements from the database</span>
        
        <span class="n">dipoleMatrixElement</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;SELECT * FROM dipoleME &#39;&#39;&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fetchall</span><span class="p">():</span>
            <span class="n">dipoleMatrixElement</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        
        <span class="c1"># obtain quadrupole matrix elements from the database</span>
        
        <span class="n">quadrupoleMatrixElement</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;SELECT * FROM quadrupoleME &#39;&#39;&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fetchall</span><span class="p">():</span>
            <span class="n">quadrupoleMatrixElement</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            
        <span class="c1"># save dipole elements</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataFolder</span><span class="p">,</span>\
                                 <span class="bp">self</span><span class="o">.</span><span class="n">dipoleMatrixElementFile</span><span class="p">),</span>\
                    <span class="n">dipoleMatrixElement</span><span class="p">)</span> 
        <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s2">&quot;Error while updating dipoleMatrixElements File &quot;</span><span class="o">+</span>\
                    <span class="bp">self</span><span class="o">.</span><span class="n">dipoleMatrixElementFile</span>
            <span class="nb">print</span> <span class="n">e</span>
        <span class="c1"># save quadrupole elements</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataFolder</span><span class="p">,</span>\
                                 <span class="bp">self</span><span class="o">.</span><span class="n">quadrupoleMatrixElementFile</span><span class="p">),</span>\
                    <span class="n">quadrupoleMatrixElement</span><span class="p">)</span> 
        <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s2">&quot;Error while updating quadrupoleMatrixElements File &quot;</span><span class="o">+</span>\
                    <span class="bp">self</span><span class="o">.</span><span class="n">quadrupoleMatrixElementFile</span>
            <span class="nb">print</span> <span class="n">e</span></div>

<div class="viewcode-block" id="AlkaliAtom.getTransitionRate"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.getTransitionRate">[docs]</a>    <span class="k">def</span> <span class="nf">getTransitionRate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">,</span><span class="n">temperature</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Transition rate due to coupling to vacuum modes (black body included)</span>
<span class="sd">            </span>
<span class="sd">            Calculates transition rate from the first given state to the second </span>
<span class="sd">            given state :math:`|n_1,l_1,j_1\\rangle \\rightarrow \</span>
<span class="sd">            |n_2,j_2,j_2\\rangle` at given temperature due to interaction with </span>
<span class="sd">            the vacuum field. For zero temperature this returns Einstein A </span>
<span class="sd">            coefficient. For details of calculation see Ref. [#lf1]_ and Ref. [#lf2]_. </span>
<span class="sd">            See `Black-body induced population transfer example snippet`_.</span>
<span class="sd">            </span>
<span class="sd">            .. _`Black-body induced population transfer example snippet`:</span>
<span class="sd">                ./Rydberg_atoms_a_primer.html#Rydberg-Atom-Lifetimes</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                n1 (int): principal quantum number </span>
<span class="sd">                l1 (int): orbital angular momentum </span>
<span class="sd">                j1 (float): total angular momentum </span>
<span class="sd">                n2 (int): principal quantum number </span>
<span class="sd">                l2 (int): orbital angular momentum </span>
<span class="sd">                j2 (float): total angular momentum</span>
<span class="sd">                [temperature] (float): temperature in K</span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                float:  transition rate in s :math:`{}^{-1}` (SI)</span>
<span class="sd">                </span>
<span class="sd">            References:</span>
<span class="sd">                .. [#lf1] C. E. Theodosiou, PRA **30**, 2881 (1984)</span>
<span class="sd">                    https://doi.org/10.1103/PhysRevA.30.2881</span>
<span class="sd">                    </span>
<span class="sd">                .. [#lf2] I. I. Beterov, I. I. Ryabtsev, D. B. Tretyakov,\</span>
<span class="sd">                    and V. M. Entin, PRA **79**, 052504 (2009)</span>
<span class="sd">                    https://doi.org/10.1103/PhysRevA.79.052504</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">degeneracyTerm</span> <span class="o">=</span> <span class="mf">1.</span>
        
        <span class="n">dipoleRadialPart</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getTransitionFrequency</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">j1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">j2</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">dipoleRadialPart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getReducedMatrixElementJ_asymmetric</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">j1</span><span class="p">,</span>\
                                                                        <span class="n">n2</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">j2</span><span class="p">)</span><span class="o">*</span>\
                                <span class="n">elemCharge</span><span class="o">*</span><span class="p">(</span><span class="n">physical_constants</span><span class="p">[</span><span class="s2">&quot;Bohr radius&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">dipoleRadialPart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getReducedMatrixElementJ_asymmetric</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">j2</span><span class="p">,</span>\
                                                                        <span class="n">n1</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">j1</span><span class="p">)</span><span class="o">*</span>\
                                <span class="n">elemCharge</span><span class="o">*</span><span class="p">(</span><span class="n">physical_constants</span><span class="p">[</span><span class="s2">&quot;Bohr radius&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">degeneracyTerm</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">j2</span><span class="o">+</span><span class="mf">1.0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">j1</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span>

        <span class="n">omega</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">getTransitionFrequency</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">j1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">j2</span><span class="p">))</span>

        <span class="n">modeOccupationTerm</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getTransitionFrequency</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">j1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">j2</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">modeOccupationTerm</span> <span class="o">=</span> <span class="mf">1.</span>
    
        <span class="c1"># only possible by absorbing thermal photons ?</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hbar</span><span class="o">*</span><span class="n">omega</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="n">temperature</span><span class="p">):</span>
            <span class="n">modeOccupationTerm</span> <span class="o">+=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">hbar</span><span class="o">*</span><span class="n">omega</span><span class="o">/</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">temperature</span><span class="p">))</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">omega</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">dipoleRadialPart</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span>\
            <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">epsilon_0</span><span class="o">*</span><span class="n">hbar</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>\
            <span class="o">*</span><span class="n">degeneracyTerm</span><span class="o">*</span><span class="n">modeOccupationTerm</span></div>
    
<div class="viewcode-block" id="AlkaliAtom.getStateLifetime"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.getStateLifetime">[docs]</a>    <span class="k">def</span> <span class="nf">getStateLifetime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">temperature</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">includeLevelsUpTo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns the lifetime of the state (in s)</span>
<span class="sd">            </span>
<span class="sd">            For non-zero temperatures, user must specify up to which principal</span>
<span class="sd">            quantum number levels, that is **above** the initial state, should be</span>
<span class="sd">            included in order to account for black-body induced transitions to </span>
<span class="sd">            higher lying states. See `Rydberg lifetimes example snippet`_.</span>
<span class="sd">            </span>
<span class="sd">            .. _`Rydberg lifetimes example snippet`:</span>
<span class="sd">                ./Rydberg_atoms_a_primer.html#Rydberg-Atom-Lifetimes</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                n, l, j (int,int,float): specifies state whose lifetime we are calculating</span>
<span class="sd">                temperature : optional. Temperature at which the atom environment</span>
<span class="sd">                    is, measured in K. If this parameter is non-zero, user has</span>
<span class="sd">                    to specify transitions up to which state (due to black-body</span>
<span class="sd">                    decay) should be included in calculation.</span>
<span class="sd">                includeLevelsUpTo (int): optional and not needed for atom lifetimes</span>
<span class="sd">                    calculated at zero temperature. At non zero temperatures,</span>
<span class="sd">                    this specify maximum principal quantum number of the state</span>
<span class="sd">                    to which black-body induced transitions will be included.</span>
<span class="sd">                    Minimal value of the parameter in that case is :math:`n+1`</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                float:</span>
<span class="sd">                    State lifetime in units of s (seconds)</span>
<span class="sd">                </span>
<span class="sd">            See also:</span>
<span class="sd">                :obj:`getTransitionRate` for calculating rates of individual</span>
<span class="sd">                transition rates between the two states</span>
<span class="sd">                </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">temperature</span><span class="o">&gt;</span><span class="mf">0.1</span> <span class="ow">and</span> <span class="n">includeLevelsUpTo</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;For non-zero temperatures, user has to specify </span><span class="se">\</span>
<span class="s2">            principal quantum number of the maximum state *above* the state for</span><span class="se">\</span>
<span class="s2">             which we are calculating the lifetime. This is in order to include </span><span class="se">\</span>
<span class="s2">             black-body induced transitions to higher lying up in energy levels.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">temperature</span><span class="o">&lt;</span><span class="mf">0.1</span><span class="p">):</span>
            <span class="n">includeLevelsUpTo</span> <span class="o">=</span> <span class="n">n</span>
            
        <span class="n">transitionRate</span> <span class="o">=</span> <span class="mf">0.</span>
        
        <span class="k">for</span> <span class="n">nto</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groundStateN</span><span class="p">,</span><span class="n">includeLevelsUpTo</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        
            <span class="c1"># sum over all l-1</span>
            <span class="k">if</span> <span class="n">l</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">lto</span> <span class="o">=</span> <span class="n">l</span><span class="o">-</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">lto</span> <span class="o">&gt;</span> <span class="n">j</span><span class="o">-</span><span class="mf">0.5</span><span class="o">-</span><span class="mf">0.1</span><span class="p">:</span>
                    <span class="n">jto</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="n">transitionRate</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getTransitionRate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">,</span>\
                                                            <span class="n">nto</span><span class="p">,</span> <span class="n">lto</span><span class="p">,</span> <span class="n">jto</span><span class="p">,</span>\
                                                            <span class="n">temperature</span><span class="p">)</span>
                <span class="n">jto</span> <span class="o">=</span> <span class="n">j</span><span class="o">-</span><span class="mf">1.</span>
                <span class="k">if</span> <span class="n">jto</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">transitionRate</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getTransitionRate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">,</span>\
                                                             <span class="n">nto</span><span class="p">,</span> <span class="n">lto</span><span class="p">,</span> <span class="n">jto</span><span class="p">,</span>\
                                                             <span class="n">temperature</span><span class="p">)</span>
            
            <span class="c1"># sum over all l+1</span>
            <span class="n">lto</span> <span class="o">=</span> <span class="n">l</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">lto</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">-</span><span class="mf">0.1</span><span class="o">&lt;</span> <span class="n">j</span> <span class="p">:</span>
                <span class="n">jto</span> <span class="o">=</span> <span class="n">j</span>
                <span class="n">transitionRate</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getTransitionRate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">,</span>\
                                                             <span class="n">nto</span><span class="p">,</span> <span class="n">lto</span><span class="p">,</span> <span class="n">jto</span><span class="p">,</span>\
                                                             <span class="n">temperature</span><span class="p">)</span>
            <span class="n">jto</span> <span class="o">=</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">transitionRate</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getTransitionRate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">,</span>\
                                                    <span class="n">nto</span><span class="p">,</span> <span class="n">lto</span><span class="p">,</span> <span class="n">jto</span><span class="p">,</span>\
                                                    <span class="n">temperature</span><span class="p">)</span>
        <span class="c1"># sum over additional states</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">extraLevels</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">&lt;</span><span class="mf">0.6</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">!=</span> <span class="n">l</span><span class="p">):</span>
                <span class="n">transitionRate</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getTransitionRate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">,</span>\
                                                    <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>\
                                                    <span class="n">temperature</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="mf">1.</span><span class="o">/</span><span class="n">transitionRate</span></div>
      
<div class="viewcode-block" id="AlkaliAtom.getRadialCoupling"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.getRadialCoupling">[docs]</a>    <span class="k">def</span> <span class="nf">getRadialCoupling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns radial part of the coupling between two states (dipole and </span>
<span class="sd">            quadrupole interactions only)</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                n1 (int): principal quantum number </span>
<span class="sd">                l1 (int): orbital angular momentum </span>
<span class="sd">                j1 (float): total angular momentum </span>
<span class="sd">                n2 (int): principal quantum number </span>
<span class="sd">                l2 (int): orbital angular momentum </span>
<span class="sd">                j2 (float): total angular momentum</span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                float:  radial coupling strength (in a.u.), or zero for forbidden </span>
<span class="sd">                transitions in dipole and quadrupole approximation.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dl</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="n">l1</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dl</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">j1</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1.1</span><span class="p">):</span>
            <span class="c1">#print n,&quot; &quot;,l,&quot; &quot;,j,&quot; &quot;,n1,&quot; &quot;,l1,&quot; &quot;,j1</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRadialMatrixElement</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">dl</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">dl</span><span class="o">==</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">dl</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span> <span class="ow">and</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">j1</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">2.1</span><span class="p">):</span>
            <span class="c1"># quadrupole coupling</span>
            <span class="c1">#return 0.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getQuadrupoleMatrixElement</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># neglect octopole coupling and higher</span>
            <span class="c1">#print &quot;NOTE: Neglecting couplings higher then quadrupole&quot;</span>
            <span class="k">return</span> <span class="mi">0</span></div>
        
<div class="viewcode-block" id="AlkaliAtom.getAverageSpeed"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.getAverageSpeed">[docs]</a>    <span class="k">def</span> <span class="nf">getAverageSpeed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">temperature</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Average one-dimensional speed at a given temperature</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                temperature (float): temperature (K)</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                float: average 1D speed (m/s)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="n">temperature</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">mass</span><span class="p">)</span></div>
    
    <span class="k">def</span> <span class="nf">_readLiteratureValues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># clear previously saved results, since literature file</span>
        <span class="c1"># might have been updated in the meantime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;DROP TABLE IF EXISTS literatureDME&#39;&#39;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;SELECT COUNT(*) FROM sqlite_master </span>
<span class="s1">                        WHERE type=&#39;table&#39; AND name=&#39;literatureDME&#39;;&#39;&#39;&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># create table</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;CREATE TABLE IF NOT EXISTS literatureDME</span>
<span class="s1">             (n1 TINYINT UNSIGNED, l1 TINYINT UNSIGNED, j1_x2 TINYINT UNSIGNED,</span>
<span class="s1">             n2 TINYINT UNSIGNED, l2 TINYINT UNSIGNED, j2_x2 TINYINT UNSIGNED,</span>
<span class="s1">             dme DOUBLE,</span>
<span class="s1">             typeOfSource TINYINT,</span>
<span class="s1">             errorEstimate DOUBLE,</span>
<span class="s1">             comment TINYTEXT,</span>
<span class="s1">             ref TINYTEXT,</span>
<span class="s1">             refdoi TINYTEXT</span>
<span class="s1">            );&#39;&#39;&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;CREATE INDEX compositeIndex </span>
<span class="s1">            ON literatureDME (n1,l1,j1_x2,n2,l2,j2_x2); &#39;&#39;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">literatureDMEfilename</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1"># no file specified for literature values</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataFolder</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">literatureDMEfilename</span><span class="p">),</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">data</span><span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;;&quot;</span><span class="p">,</span><span class="n">quotechar</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">)</span>
            
            <span class="n">literatureDME</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="c1"># i=0 is header</span>
            <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">n1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">l1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">j1</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">n2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                    <span class="n">l2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
                    <span class="n">j2</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
                    <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">j1</span><span class="p">)</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">j2</span><span class="p">)):</span>
                        <span class="n">temp</span> <span class="o">=</span> <span class="n">n1</span>
                        <span class="n">n1</span> <span class="o">=</span> <span class="n">n2</span>
                        <span class="n">n2</span> <span class="o">=</span> <span class="n">temp</span>
                        <span class="n">temp</span> <span class="o">=</span> <span class="n">l1</span>
                        <span class="n">l1</span> <span class="o">=</span> <span class="n">l2</span>
                        <span class="n">l2</span> <span class="o">=</span> <span class="n">temp</span>
                        <span class="n">temp</span> <span class="o">=</span> <span class="n">j1</span>
                        <span class="n">j1</span> <span class="o">=</span> <span class="n">j2</span>
                        <span class="n">j2</span> <span class="o">=</span> <span class="n">temp</span>
                    
                    <span class="c1"># convered from reduced DME in J basis (symmetric notation) </span>
                    <span class="c1"># to DME as it is saved for calculated values</span>
                    <span class="n">dme</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span><span class="o">/</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">l1</span><span class="o">+</span><span class="mf">0.5</span><span class="o">+</span><span class="n">j2</span><span class="o">+</span><span class="mf">1.</span><span class="p">))</span><span class="o">*</span>\
                                <span class="n">sqrt</span><span class="p">((</span><span class="mf">2.</span><span class="o">*</span><span class="n">j1</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">j2</span><span class="o">+</span><span class="mf">1.</span><span class="p">))</span><span class="o">*</span>\
                                <span class="n">Wigner6j</span><span class="p">(</span><span class="n">j1</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">j2</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">l1</span><span class="p">))</span>
                    <span class="n">comment</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
                    <span class="n">typeOfSource</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span>  <span class="c1"># 0 = experiment; 1 = theory</span>
                    <span class="n">errorEstimate</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">9</span><span class="p">])</span>
                    <span class="n">ref</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
                    <span class="n">refdoi</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span>
                    
                    <span class="n">literatureDME</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">dme</span><span class="p">,</span>\
                                               <span class="n">typeOfSource</span><span class="p">,</span><span class="n">errorEstimate</span><span class="p">,</span>\
                                               <span class="n">comment</span><span class="p">,</span><span class="n">ref</span><span class="p">,</span>\
                                                    <span class="n">refdoi</span><span class="p">])</span>
                <span class="n">i</span> <span class="o">+=</span><span class="mi">1</span>
            <span class="n">fn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;INSERT INTO literatureDME </span>
<span class="s1">                                    VALUES (?,?,?,?,?,?,?,</span>
<span class="s1">                                            ?,?,?,?,?)&#39;&#39;&#39;</span><span class="p">,</span>\
                                     <span class="n">literatureDME</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">Error</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s2">&quot;Error while loading precalculated values into the database&quot;</span>
                <span class="nb">print</span> <span class="n">e</span>
                <span class="n">exit</span><span class="p">()</span>  
                
            
            
                
        <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s2">&quot;Error reading literature values File &quot;</span><span class="o">+</span>\
                    <span class="bp">self</span><span class="o">.</span><span class="n">literatureDMEfilename</span>
            <span class="nb">print</span> <span class="n">e</span>
        
        
    
<div class="viewcode-block" id="AlkaliAtom.getLiteratureDME"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.AlkaliAtom.getLiteratureDME">[docs]</a>    <span class="k">def</span> <span class="nf">getLiteratureDME</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns literature information on requested transition.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                n1,l1,j1: one of the states we are coupling</span>
<span class="sd">                n2,l2,j2: the other state to which we are coupling</span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                bool, float, [int,float,string,string,string]:</span>

<span class="sd">                    hasLiteratureValue?, dme, referenceInformation</span>

<span class="sd">                    **If Boolean value is True**, a literature value for dipole matrix</span>
<span class="sd">                    element was found and reduced DME in J basis is returned</span>
<span class="sd">                    as the number. Third returned argument (array) contains </span>
<span class="sd">                    additional information about the literature value in the </span>
<span class="sd">                    following order [ typeOfSource, errorEstimate , comment ,</span>
<span class="sd">                    reference, reference DOI] upon success to</span>
<span class="sd">                    find a literature value for dipole matrix element:</span>
<span class="sd">                        * typeOfSource=1 if the value is theoretical calculation;\</span>
<span class="sd">                         otherwise, if it is experimentally obtained value\</span>
<span class="sd">                         typeOfSource=0</span>
<span class="sd">                        * comment details where within the publication the value\</span>
<span class="sd">                         can be found</span>
<span class="sd">                        * errorEstimate is absolute error estimate</span>
<span class="sd">                        * reference is human-readable formatted reference</span>
<span class="sd">                        * reference DOI provides link to the publication.</span>
<span class="sd">                    </span>
<span class="sd">                    **Boolean value is False**, followed by zero and an empty array</span>
<span class="sd">                    if no literature value for dipole matrix element is found.</span>
<span class="sd">                </span>
<span class="sd">            Note:</span>
<span class="sd">                The literature values are stored in /data folder in </span>
<span class="sd">                &lt;element name&gt;_literature_dme.csv files as a ; separated values.</span>
<span class="sd">                Each row in the file consists of one literature entry, that has </span>
<span class="sd">                information in the following order:</span>
<span class="sd">                </span>
<span class="sd">                 * n1</span>
<span class="sd">                 * l1</span>
<span class="sd">                 * j1 </span>
<span class="sd">                 * n2</span>
<span class="sd">                 * l2</span>
<span class="sd">                 * j2</span>
<span class="sd">                 * dipole matrix element reduced l basis (a.u.)</span>
<span class="sd">                 * comment (e.g. where in the paper value appears?)</span>
<span class="sd">                 * value origin: 1 for theoretical; 0 for experimental values</span>
<span class="sd">                 * accuracy</span>
<span class="sd">                 * source (human readable formatted citation)</span>
<span class="sd">                 * doi number (e.g. 10.1103/RevModPhys.82.2313 )</span>
<span class="sd">                 </span>
<span class="sd">                If there are several values for a given transition, program will</span>
<span class="sd">                output the value that has smallest error (under column accuracy).</span>
<span class="sd">                The list of values can be expanded - every time program runs</span>
<span class="sd">                this file is read and the list is parsed again for use in </span>
<span class="sd">                calculations. </span>
<span class="sd">                </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">j1</span><span class="p">)</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">getEnergy</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">j2</span><span class="p">)):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">n1</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="n">n2</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">temp</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">l1</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">l2</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">temp</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">j1</span>
            <span class="n">j1</span> <span class="o">=</span> <span class="n">j2</span>
            <span class="n">j2</span> <span class="o">=</span> <span class="n">temp</span>
        
        
        <span class="c1"># is there literature value for this DME? If there is, </span>
        <span class="c1"># use the best one (wit the smallest error)</span>

        <span class="n">j1_x2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">j1</span>
        <span class="n">j2_x2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">j2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;SELECT dme, typeOfSource,</span>
<span class="s1">                     errorEstimate ,</span>
<span class="s1">                     comment ,</span>
<span class="s1">                     ref,</span>
<span class="s1">                     refdoi FROM literatureDME WHERE</span>
<span class="s1">                     n1= ? AND l1 = ? AND j1_x2 = ? AND </span>
<span class="s1">                     n2 = ? AND l2 = ? AND j2_x2 = ? </span>
<span class="s1">                     ORDER BY errorEstimate ASC&#39;&#39;&#39;</span><span class="p">,</span>\
                     <span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1_x2</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2_x2</span><span class="p">))</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">answer</span><span class="p">):</span>
            <span class="c1"># we did found literature value</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span><span class="n">answer</span><span class="p">[</span><span class="mi">0</span><span class="p">],[</span><span class="n">answer</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">answer</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">answer</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>\
                                   <span class="n">answer</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="n">answer</span><span class="p">[</span><span class="mi">5</span><span class="p">]]</span>
        
        <span class="c1"># if we are here, we were unsucessfull in literature search for this value</span>
        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span><span class="mi">0</span><span class="p">,[]</span></div></div>
    


<div class="viewcode-block" id="NumerovBack"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.NumerovBack">[docs]</a><span class="k">def</span> <span class="nf">NumerovBack</span><span class="p">(</span><span class="n">innerLimit</span><span class="p">,</span><span class="n">outerLimit</span><span class="p">,</span><span class="n">kfun</span><span class="p">,</span><span class="n">step</span><span class="p">,</span><span class="n">init1</span><span class="p">,</span><span class="n">init2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Full Python implementation of Numerov integration</span>
<span class="sd">        </span>
<span class="sd">        Calculates solution function :math:`rad(r)` with descrete step in </span>
<span class="sd">        :math:`r` size of `step`, integrating from `outerLimit` towards the </span>
<span class="sd">        `innerLimit` (from outside, inwards) equation</span>
<span class="sd">        :math:`\\frac{\\mathrm{d}^2 rad(r)}{\\mathrm{d} r^2} = kfun(r)\\cdot rad(r)`.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">            </span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            innerLimit (float): inner limit of integration</span>
<span class="sd">            outerLimit (flaot): outer limit of integration</span>
<span class="sd">            kfun (function(double)): pointer to function used in equation (see </span>
<span class="sd">                longer explanation above)</span>
<span class="sd">            step: descrete step size for integration</span>
<span class="sd">            init1 (float): initial value, `rad`(`outerLimit`+`step`)</span>
<span class="sd">            init2 (float): initial value, `rad`(`outerLimit`+:math:`2\\cdot` `step`)</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            numpy array of float , numpy array of float, int : :math:`r` (a.u), </span>
<span class="sd">            :math:`rad(r)`, divergencePoint;</span>
<span class="sd">                divergencePoint is zero if no divergence occurred before reaching </span>
<span class="sd">                `innerLimit`. Otherwise, if divergence occurred before </span>
<span class="sd">                reaching `innerLimit`, divergencePoint is index of the first </span>
<span class="sd">                element in the returned array which is outside the divergence </span>
<span class="sd">                region.</span>
<span class="sd">                </span>
<span class="sd">        Note:</span>
<span class="sd">            Returned function is not normalized!</span>
<span class="sd">        </span>
<span class="sd">        Note:</span>
<span class="sd">            If :obj:`AlkaliAtom.cpp_numerov` swich is set to True (default option), </span>
<span class="sd">            much faster C++ algorithm will be used instead. That is recommended </span>
<span class="sd">            option. Just make sure that there is executabeble nvwcpp located in</span>
<span class="sd">            the package folder. You can build this executable, e.g. by using</span>
<span class="sd">            the GNU C++ compiler yourself by calling from the command line::</span>
<span class="sd">                </span>
<span class="sd">                g++ -O3 nwvcpp.cpp -o nvwcpp</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">br</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">outerLimit</span><span class="o">-</span><span class="n">innerLimit</span><span class="p">)</span><span class="o">/</span><span class="n">step</span><span class="p">)</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">br</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">))</span>
    <span class="n">rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">br</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">))</span>
    
    <span class="n">br</span> <span class="o">=</span> <span class="n">br</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">outerLimit</span>
    <span class="n">sol</span><span class="p">[</span><span class="n">br</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="mf">5.0</span><span class="o">/</span><span class="mf">12.0</span><span class="o">*</span><span class="n">step</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">kfun</span><span class="p">(</span><span class="n">r</span><span class="p">))</span><span class="o">*</span><span class="n">init1</span><span class="o">-</span>\
               <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="mf">1.</span><span class="o">/</span><span class="mf">12.0</span><span class="o">*</span><span class="n">step</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">kfun</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="n">step</span><span class="p">))</span><span class="o">*</span><span class="n">init2</span><span class="p">)</span><span class="o">/</span>\
               <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="mf">12.0</span><span class="o">*</span><span class="n">step</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">kfun</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">step</span><span class="p">))</span>
    <span class="n">rad</span><span class="p">[</span><span class="n">br</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
    
    <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">-</span><span class="n">step</span>
    <span class="n">br</span> <span class="o">=</span> <span class="n">br</span><span class="o">-</span><span class="mi">1</span>
    
    <span class="n">sol</span><span class="p">[</span><span class="n">br</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="mf">5.0</span><span class="o">/</span><span class="mf">12.0</span><span class="o">*</span><span class="n">step</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">kfun</span><span class="p">(</span><span class="n">r</span><span class="p">))</span><span class="o">*</span><span class="n">sol</span><span class="p">[</span><span class="n">br</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span>\
               <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="mf">1.</span><span class="o">/</span><span class="mf">12.0</span><span class="o">*</span><span class="n">step</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">kfun</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="n">step</span><span class="p">))</span><span class="o">*</span><span class="n">init1</span><span class="p">)</span><span class="o">/</span>\
               <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="mf">12.0</span><span class="o">*</span><span class="n">step</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">kfun</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">step</span><span class="p">))</span>
    <span class="n">rad</span><span class="p">[</span><span class="n">br</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
    
    <span class="c1"># check if the function starts diverging  before the innerLimit </span>
    <span class="c1"># -&gt; in that case break integration earlier</span>
    
    <span class="n">maxValue</span> <span class="o">=</span> <span class="mf">0.</span>

    <span class="n">checkPoint</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">fromLastMax</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">while</span> <span class="n">br</span><span class="o">&gt;</span><span class="n">checkPoint</span><span class="p">:</span>
        <span class="n">br</span> <span class="o">=</span> <span class="n">br</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">-</span><span class="n">step</span>
        <span class="n">sol</span><span class="p">[</span><span class="n">br</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="mf">5.0</span><span class="o">/</span><span class="mf">12.0</span><span class="o">*</span><span class="n">step</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">kfun</span><span class="p">(</span><span class="n">r</span><span class="p">))</span><span class="o">*</span><span class="n">sol</span><span class="p">[</span><span class="n">br</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span>\
                   <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="mf">1.</span><span class="o">/</span><span class="mf">12.0</span><span class="o">*</span><span class="n">step</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">kfun</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="n">step</span><span class="p">))</span><span class="o">*</span><span class="n">sol</span><span class="p">[</span><span class="n">br</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span>\
                   <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="mf">1.</span><span class="o">/</span><span class="mf">12.0</span><span class="o">*</span><span class="n">step</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">kfun</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">step</span><span class="p">))</span>
        <span class="n">rad</span><span class="p">[</span><span class="n">br</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="n">br</span><span class="p">])</span><span class="o">&gt;</span><span class="n">maxValue</span><span class="p">:</span>
            <span class="n">maxValue</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="n">br</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fromLastMax</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">fromLastMax</span><span class="o">&gt;</span><span class="mi">50</span><span class="p">:</span>
                <span class="n">checkPoint</span> <span class="o">=</span> <span class="n">br</span>
    <span class="c1"># now proceed with caution - checking if the divergence starts </span>
    <span class="c1"># - if it does, cut earlier</span>
    
    <span class="n">divergencePoint</span> <span class="o">=</span> <span class="mi">0</span>
       
    <span class="k">while</span> <span class="p">(</span><span class="n">br</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="ow">and</span><span class="p">(</span><span class="n">divergencePoint</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">br</span> <span class="o">=</span> <span class="n">br</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">-</span><span class="n">step</span>
        <span class="n">sol</span><span class="p">[</span><span class="n">br</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="mf">5.0</span><span class="o">/</span><span class="mf">12.0</span><span class="o">*</span><span class="n">step</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">kfun</span><span class="p">(</span><span class="n">r</span><span class="p">))</span><span class="o">*</span><span class="n">sol</span><span class="p">[</span><span class="n">br</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span>\
                   <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="mf">1.</span><span class="o">/</span><span class="mf">12.0</span><span class="o">*</span><span class="n">step</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">kfun</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="n">step</span><span class="p">))</span><span class="o">*</span><span class="n">sol</span><span class="p">[</span><span class="n">br</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span>\
                   <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="mf">1.</span><span class="o">/</span><span class="mf">12.0</span><span class="o">*</span><span class="n">step</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">kfun</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">step</span><span class="p">))</span>
        <span class="n">rad</span><span class="p">[</span><span class="n">br</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">divergencePoint</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="ow">and</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="n">br</span><span class="p">])</span><span class="o">&gt;</span><span class="n">maxValue</span><span class="p">):</span>
            <span class="n">divergencePoint</span> <span class="o">=</span> <span class="n">br</span>
            <span class="k">while</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="n">divergencePoint</span><span class="p">])</span><span class="o">&gt;</span><span class="nb">abs</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="n">divergencePoint</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span> <span class="ow">and</span> \
                <span class="p">(</span><span class="n">divergencePoint</span><span class="o">&lt;</span><span class="n">checkPoint</span><span class="p">):</span>
                <span class="n">divergencePoint</span> <span class="o">+=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">divergencePoint</span><span class="o">&gt;</span><span class="n">checkPoint</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s2">&quot;Numerov error&quot;</span>
                <span class="n">exit</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">rad</span><span class="p">,</span><span class="n">sol</span><span class="p">,</span><span class="n">divergencePoint</span></div>


<span class="k">def</span> <span class="nf">_atomLightAtomCoupling</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">nn</span><span class="p">,</span><span class="n">ll</span><span class="p">,</span><span class="n">jj</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">,</span><span class="n">atom</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates radial part of atom-light coupling</span>
<span class="sd">    </span>
<span class="sd">        This function might seem redundant, since similar function exist for</span>
<span class="sd">        each of the atoms. However, function that is not connected to specific</span>
<span class="sd">        atomic species is provided in order to provides route to implement </span>
<span class="sd">        inter-species coupling in the future.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># determine coupling</span>
    <span class="n">dl</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="n">l1</span><span class="p">)</span>
    <span class="n">dj</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">j1</span><span class="p">)</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">dl</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dj</span><span class="o">&lt;</span><span class="mf">1.1</span><span class="p">):</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># dipole coupling</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">dl</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">dl</span><span class="o">==</span><span class="mi">2</span> <span class="ow">or</span> <span class="n">dl</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span><span class="p">(</span><span class="n">dj</span><span class="o">&lt;</span><span class="mf">2.1</span><span class="p">):</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># quadrupole coupling</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">dl</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ll</span><span class="o">-</span><span class="n">l2</span><span class="p">)</span>
    <span class="n">dj</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">jj</span><span class="o">-</span><span class="n">j2</span><span class="p">)</span>
    <span class="n">c2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">dl</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dj</span><span class="o">&lt;</span><span class="mf">1.1</span><span class="p">):</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># dipole coupling</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">dl</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">dl</span><span class="o">==</span><span class="mi">2</span> <span class="ow">or</span> <span class="n">dl</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span><span class="p">(</span><span class="n">dj</span><span class="o">&lt;</span><span class="mf">2.1</span><span class="p">):</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># quadrupole coupling                                  </span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    
    <span class="n">radial1</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">getRadialCoupling</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">)</span>
    <span class="n">radial2</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">getRadialCoupling</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span><span class="n">ll</span><span class="p">,</span><span class="n">jj</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">)</span>
    
    <span class="c1">## TO-DO: check exponent of the Boht radius (from where it comes?!)</span>
    
    <span class="n">coupling</span> <span class="o">=</span> <span class="n">elemCharge</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">epsilon_0</span><span class="p">)</span><span class="o">*</span><span class="n">radial1</span><span class="o">*</span><span class="n">radial2</span><span class="o">*</span>\
                <span class="p">(</span><span class="n">physical_constants</span><span class="p">[</span><span class="s2">&quot;Bohr radius&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="p">(</span><span class="n">c1</span><span class="o">+</span><span class="n">c2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">coupling</span>
    
    
<span class="c1"># =================== Saving and loading calculations (START) ===================</span>

<div class="viewcode-block" id="saveCalculation"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.saveCalculation">[docs]</a><span class="k">def</span> <span class="nf">saveCalculation</span><span class="p">(</span><span class="n">calculation</span><span class="p">,</span><span class="n">fileName</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Saves calculation for future use.</span>
<span class="sd">    </span>
<span class="sd">    Saves :obj:`calculations_atom_pairstate.PairStateInteractions` and </span>
<span class="sd">    :obj:`calculations_atom_single.StarkMap`</span>
<span class="sd">    calculations in compact binary format in file named `filename`. It uses</span>
<span class="sd">    cPickle serialization library in Python, and also zips the final file.</span>
<span class="sd">    </span>
<span class="sd">    Calculation can be retrieved and used with :obj:`loadSavedCalculation` </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        calculation: class instance of calculations (instance of</span>
<span class="sd">            :obj:`calculations_atom_pairstate.PairStateInteractions` </span>
<span class="sd">            or :obj:`calculations_atom_single.StarkMap`)</span>
<span class="sd">            to be saved.</span>
<span class="sd">        fileName: name of the file where calculation will be saved</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">        Let&#39;s suppose that we did the part of the </span>
<span class="sd">        :obj:`calculation_atom_pairstate.PairStateInteractions`</span>
<span class="sd">        calculation that involves generation of the interaction</span>
<span class="sd">        matrix. After that we can save the full calculation in a single file::</span>
<span class="sd">            </span>
<span class="sd">            calc = PairStateInteractions(Rubidium(), 60,0,0.5,60,0,0.5, 0.5,0.5)</span>
<span class="sd">            calc.defineBasis(0,0, 5,5, 25.e9)</span>
<span class="sd">            calc.diagonalise(np.linspace(0.5,10.0,200),150)</span>
<span class="sd">            saveCalculation(calc, &quot;mySavedCalculation.pkl&quot;)</span>
<span class="sd">        </span>
<span class="sd">        Then, at a later time, and even on the another machine, we can load</span>
<span class="sd">        that file and continue with calculation. We can for example explore</span>
<span class="sd">        the calculated level diagram::</span>
<span class="sd">        </span>
<span class="sd">            calc = loadSavedCalculation(&quot;mySavedCalculation.pkl&quot;)</span>
<span class="sd">            calc.plotLevelDiagram()</span>
<span class="sd">            calc.showPlot()</span>
<span class="sd">            rvdw = calc.getVdwFromLevelDiagram(0.5,14,minStateContribution=0.5,\\</span>
<span class="sd">                                               showPlot = True)</span>
<span class="sd">        </span>
<span class="sd">        Or, we can do additional matrix diagonalization, in some new range,</span>
<span class="sd">        then and find C6 by fitting the obtained level diagram::</span>
<span class="sd">        </span>
<span class="sd">            calc = loadSavedCalculation(&quot;mySavedCalculation.pkl&quot;)</span>
<span class="sd">            calc.diagonalise(np.linspace(3,6.0,200),20)</span>
<span class="sd">            calc.getC6fromLevelDiagram(3,6.0,showPlot=True)</span>
<span class="sd">        </span>
<span class="sd">        Note that for all loading of saved calculations we&#39;ve been using</span>
<span class="sd">        function :obj:`loadSavedCalculation` .</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        This doesn&#39;t save results of :obj:`plotLevelDiagram` for the corresponding</span>
<span class="sd">        calculations. Call the plot function before calling :obj:`showPlot` function</span>
<span class="sd">        for the corresponding calculation.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ax</span>  <span class="o">=</span> <span class="n">calculation</span><span class="o">.</span><span class="n">ax</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">calculation</span><span class="o">.</span><span class="n">fig</span>
        <span class="n">calculation</span><span class="o">.</span><span class="n">ax</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">calculation</span><span class="o">.</span><span class="n">fig</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="n">output</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">GzipFile</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">calculation</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="n">calculation</span><span class="o">.</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span>
        <span class="n">calculation</span><span class="o">.</span><span class="n">fig</span> <span class="o">=</span> <span class="n">fig</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span> <span class="s2">&quot;ERROR: saving of the calculation failed.&quot;</span>
        <span class="nb">print</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="mi">0</span></div>
    
<div class="viewcode-block" id="loadSavedCalculation"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.loadSavedCalculation">[docs]</a><span class="k">def</span> <span class="nf">loadSavedCalculation</span><span class="p">(</span><span class="n">fileName</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loads previously saved calculation.</span>
<span class="sd">    </span>
<span class="sd">    Loads :obj:`calculations_atom_pairstate.PairStateInteractions` and </span>
<span class="sd">    :obj:`calculations_atom_single.StarkMap`</span>
<span class="sd">    calculation instance from file named `filename` where it was previously saved</span>
<span class="sd">    with :obj:`saveCalculation` .</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">        See example for :obj:`saveCalculation`.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        fileName: name of the file where calculation will be saved</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        saved calculation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">calculation</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">calcInput</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">GzipFile</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
        <span class="n">calculation</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">calcInput</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span> <span class="s2">&quot;ERROR: loading of the calculation from &#39;</span><span class="si">%s</span><span class="s2">&#39; failed&quot;</span>  <span class="o">%</span> <span class="n">fileName</span>
        <span class="nb">print</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="nb">print</span> <span class="s2">&quot;Loading of &quot;</span><span class="o">+</span><span class="n">calculation</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="o">+</span><span class="s2">&quot; from &#39;&quot;</span><span class="o">+</span><span class="n">fileName</span><span class="o">+</span>\
        <span class="s2">&quot;&#39; successful.&quot;</span>
    
    <span class="c1"># establish conneciton to the database</span>
    <span class="n">calculation</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">_databaseInit</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">calculation</span></div>

<span class="c1"># =================== Saving and loading calculations (END) ===================</span>

<span class="c1"># =================== State generation and printing (START) ===================</span>

<span class="k">def</span> <span class="nf">singleAtomState</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mf">1.0</span><span class="p">,</span><span class="mi">0</span><span class="p">)),</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="n">a</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="p">))]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">a</span>
    <span class="k">return</span> <span class="n">csr_matrix</span><span class="p">(([</span><span class="mi">1</span><span class="p">],</span> <span class="p">([</span><span class="n">j</span><span class="o">+</span><span class="n">m</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">])),</span>
                                       <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mf">1.0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">compositeState</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">):</span>
    <span class="c1">#return np.kron(s1,s2)#kroneckerp(s1, s2)</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">s1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">s2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">br1</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">br2</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">s2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="n">br1</span><span class="p">]</span><span class="o">*</span><span class="n">s2</span><span class="p">[</span><span class="n">br2</span><span class="p">]</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">a</span>

<div class="viewcode-block" id="printState"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.printState">[docs]</a><span class="k">def</span> <span class="nf">printState</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prints state spectroscopic label for numeric :math:`n`, </span>
<span class="sd">        :math:`l`, :math:`s` label of the state</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            n (int): principal quantum number</span>
<span class="sd">            l (int): orbital angular momentum</span>
<span class="sd">            j (float): total angular momentum</span>
<span class="sd">    &quot;&quot;&quot;</span>
        
    <span class="nb">print</span> <span class="n">n</span><span class="p">,</span><span class="s2">&quot; &quot;</span><span class="p">,</span><span class="n">printStateLetter</span><span class="p">(</span><span class="n">l</span><span class="p">),(</span><span class="s2">&quot; </span><span class="si">%.0d</span><span class="s2">/2&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span></div>

<div class="viewcode-block" id="printStateString"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.printStateString">[docs]</a><span class="k">def</span> <span class="nf">printStateString</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns state spectroscopic label for numeric :math:`n`, </span>
<span class="sd">        :math:`l`, :math:`s` label of the state</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            n (int): principal quantum number</span>
<span class="sd">            l (int): orbital angular momentum</span>
<span class="sd">            j (float): total angular momentum</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            string: label for the state in standard spectroscopic notation</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="n">printStateLetter</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="s2">&quot; </span><span class="si">%.0d</span><span class="s2">/2&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span></div>

<div class="viewcode-block" id="printStateStringLatex"><a class="viewcode-back" href="../alkali_atom_functions.html#alkali_atom_functions.printStateStringLatex">[docs]</a><span class="k">def</span> <span class="nf">printStateStringLatex</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns latex code for spectroscopic label for numeric :math:`n`, </span>
<span class="sd">        :math:`l`, :math:`s` label of the state</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            n (int): principal quantum number</span>
<span class="sd">            l (int): orbital angular momentum</span>
<span class="sd">            j (float): total angular momentum</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            string: label for the state in standard spectroscopic notation</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">+</span><span class="n">printStateLetter</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="s2">&quot;_{</span><span class="si">%.0d</span><span class="s2">/2}&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span></div>

<span class="k">def</span> <span class="nf">printStateLetter</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
    <span class="n">let</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">if</span> <span class="n">l</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">let</span> <span class="o">=</span> <span class="s2">&quot;S&quot;</span>
    <span class="k">elif</span> <span class="n">l</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">let</span> <span class="o">=</span> <span class="s2">&quot;P&quot;</span>
    <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">let</span> <span class="o">=</span> <span class="s2">&quot;D&quot;</span>
    <span class="k">elif</span> <span class="n">l</span><span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">let</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span>
    <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">let</span> <span class="o">=</span> <span class="s2">&quot;G&quot;</span>
    <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="n">let</span> <span class="o">=</span> <span class="s2">&quot;H&quot;</span>
    <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
        <span class="n">let</span> <span class="o">=</span> <span class="s2">&quot;I&quot;</span>
    <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
        <span class="n">let</span> <span class="o">=</span> <span class="s2">&quot;K&quot;</span>
    <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
        <span class="n">let</span> <span class="o">=</span> <span class="s2">&quot;L&quot;</span>
    <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">9</span><span class="p">:</span>
        <span class="n">let</span> <span class="o">=</span> <span class="s2">&quot;M&quot;</span>
    <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">let</span> <span class="o">=</span> <span class="s2">&quot;N&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">let</span> <span class="o">=</span> <span class="s2">&quot; l=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">l</span>
    <span class="k">return</span> <span class="n">let</span>

<span class="c1"># =================== State generation and printing (END) ===================</span>

<span class="c1"># =================== E FIELD Coupling (START) ===================</span>

<span class="k">class</span> <span class="nc">_EFieldCoupling</span><span class="p">:</span>
    <span class="n">dataFolder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">__file__</span><span class="p">)),</span><span class="s2">&quot;data&quot;</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="n">phi</span>
        
        <span class="c1"># STARK memoization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataFolder</span><span class="p">,</span>\
                                                 <span class="s2">&quot;precalculated_stark.db&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
        
        
        <span class="c1">### ANGULAR PARTS</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;SELECT COUNT(*) FROM sqlite_master </span>
<span class="s1">                            WHERE type=&#39;table&#39; AND name=&#39;eFieldCoupling_angular&#39;;&#39;&#39;&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># create table</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;CREATE TABLE IF NOT EXISTS eFieldCoupling_angular</span>
<span class="s1">             (l1 TINYINT UNSIGNED, j1_x2 TINYINT UNSIGNED, j1_mj1 TINYINT UNSIGNED,</span>
<span class="s1">              l2 TINYINT UNSIGNED, j2_x2 TINYINT UNSIGNED, j2_mj2 TINYINT UNSIGNED,</span>
<span class="s1">             sumPart DOUBLE,</span>
<span class="s1">             PRIMARY KEY (l1,j1_x2,j1_mj1,l2,j2_x2,j2_mj2)</span>
<span class="s1">            ) &#39;&#39;&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
            
        <span class="c1">###COUPLINGS IN ROTATED BASIS (depend on theta, phi)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wgd</span> <span class="o">=</span> <span class="n">wignerDmatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;DROP TABLE IF EXISTS eFieldCoupling&#39;&#39;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;SELECT COUNT(*) FROM sqlite_master </span>
<span class="s1">                            WHERE type=&#39;table&#39; AND name=&#39;eFieldCoupling&#39;;&#39;&#39;&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># create table</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;CREATE TABLE IF NOT EXISTS eFieldCoupling</span>
<span class="s1">             (l1 TINYINT UNSIGNED, j1_x2 TINYINT UNSIGNED, j1_mj1 TINYINT UNSIGNED,</span>
<span class="s1">              l2 TINYINT UNSIGNED, j2_x2 TINYINT UNSIGNED, j2_mj2 TINYINT UNSIGNED,</span>
<span class="s1">             coupling DOUBLE,</span>
<span class="s1">             PRIMARY KEY (l1,j1_x2,j1_mj1,l2,j2_x2,j2_mj2)</span>
<span class="s1">            ) &#39;&#39;&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">getAngular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">mj1</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">,</span><span class="n">mj2</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;SELECT sumPart FROM eFieldCoupling_angular WHERE</span>
<span class="s1">         l1= ? AND j1_x2 = ? AND j1_mj1 = ? AND </span>
<span class="s1">         l2 = ? AND j2_x2 = ? AND j2_mj2 = ? </span>
<span class="s1">         &#39;&#39;&#39;</span><span class="p">,(</span><span class="n">l1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">j1</span><span class="p">,</span><span class="n">j1</span><span class="o">+</span><span class="n">mj1</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">j2</span><span class="o">+</span><span class="n">mj2</span><span class="p">))</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">answer</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">answer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># calulates sum (See PRA 20:2251 (1979), eq.(10))</span>
        <span class="n">sumPart</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">ml</span> <span class="o">=</span> <span class="n">mj1</span> <span class="o">+</span> <span class="mf">0.5</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">ml</span><span class="p">)</span><span class="o">-</span><span class="mf">0.1</span><span class="o">&lt;</span><span class="n">l1</span><span class="p">)</span><span class="ow">and</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">ml</span><span class="p">)</span><span class="o">-</span><span class="mf">0.1</span><span class="o">&lt;</span><span class="n">l2</span><span class="p">):</span>

            <span class="n">angularPart</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">l1</span><span class="o">-</span><span class="n">l2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">0.1</span><span class="p">):</span>
                <span class="n">angularPart</span> <span class="o">=</span> <span class="p">((</span><span class="n">l1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">ml</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mf">2.</span><span class="o">*</span><span class="n">l1</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">l1</span><span class="o">-</span><span class="mf">1.</span><span class="p">)))</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="k">elif</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">l1</span><span class="o">-</span><span class="n">l2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">0.1</span><span class="p">):</span>
                <span class="n">angularPart</span> <span class="o">=</span> <span class="p">((</span><span class="n">l2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">ml</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mf">2.</span><span class="o">*</span><span class="n">l2</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">l2</span><span class="o">-</span><span class="mf">1.</span><span class="p">)))</span><span class="o">**</span><span class="mf">0.5</span>

            <span class="n">sumPart</span> <span class="o">+=</span> <span class="n">CG</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">ml</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="n">mj1</span><span class="o">-</span><span class="n">ml</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">mj1</span><span class="p">)</span><span class="o">*</span><span class="n">CG</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span><span class="n">ml</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="n">mj1</span><span class="o">-</span><span class="n">ml</span><span class="p">,</span><span class="n">j2</span><span class="p">,</span><span class="n">mj2</span><span class="p">)</span><span class="o">*</span>\
                        <span class="n">angularPart</span>

        
        <span class="n">ml</span> <span class="o">=</span> <span class="n">mj1</span> <span class="o">-</span> <span class="mf">0.5</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">ml</span><span class="p">)</span><span class="o">-</span><span class="mf">0.1</span><span class="o">&lt;</span><span class="n">l1</span><span class="p">)</span><span class="ow">and</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">ml</span><span class="p">)</span><span class="o">-</span><span class="mf">0.1</span><span class="o">&lt;</span><span class="n">l2</span><span class="p">):</span>
            <span class="n">angularPart</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">l1</span><span class="o">-</span><span class="n">l2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">0.1</span><span class="p">):</span>
                <span class="n">angularPart</span> <span class="o">=</span> <span class="p">((</span><span class="n">l1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">ml</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mf">2.</span><span class="o">*</span><span class="n">l1</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">l1</span><span class="o">-</span><span class="mf">1.</span><span class="p">)))</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="k">elif</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">l1</span><span class="o">-</span><span class="n">l2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">0.1</span><span class="p">):</span>
                <span class="n">angularPart</span> <span class="o">=</span> <span class="p">((</span><span class="n">l2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">ml</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mf">2.</span><span class="o">*</span><span class="n">l2</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">l2</span><span class="o">-</span><span class="mf">1.</span><span class="p">)))</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="n">sumPart</span> <span class="o">+=</span> <span class="n">CG</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">ml</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="n">mj1</span><span class="o">-</span><span class="n">ml</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">mj1</span><span class="p">)</span><span class="o">*</span><span class="n">CG</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span><span class="n">ml</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="n">mj1</span><span class="o">-</span><span class="n">ml</span><span class="p">,</span><span class="n">j2</span><span class="p">,</span><span class="n">mj2</span><span class="p">)</span><span class="o">*</span>\
                        <span class="n">angularPart</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39; INSERT INTO eFieldCoupling_angular </span>
<span class="s1">                            VALUES (?,?,?, ?,?,?, ?)&#39;&#39;&#39;</span><span class="p">,</span>\
                            <span class="p">[</span><span class="n">l1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">j1</span><span class="p">,</span><span class="n">j1</span><span class="o">+</span><span class="n">mj1</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">j2</span><span class="o">+</span><span class="n">mj2</span><span class="p">,</span><span class="n">sumPart</span><span class="p">]</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">sumPart</span>
    
    <span class="k">def</span> <span class="nf">getCouplingDivEDivDME</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">mj1</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">,</span><span class="n">mj2</span><span class="p">):</span>
        <span class="c1"># returns angular coupling without radial part and electric field</span>
        
        <span class="c1"># if calculated before, retrieve from memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;SELECT coupling FROM eFieldCoupling WHERE</span>
<span class="s1">         l1= ? AND j1_x2 = ? AND j1_mj1 = ? AND </span>
<span class="s1">         l2 = ? AND j2_x2 = ? AND j2_mj2 = ? </span>
<span class="s1">         &#39;&#39;&#39;</span><span class="p">,(</span><span class="n">l1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">j1</span><span class="p">,</span><span class="n">j1</span><span class="o">+</span><span class="n">mj1</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">j2</span><span class="o">+</span><span class="n">mj2</span><span class="p">))</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">answer</span><span class="p">):</span>
            <span class="c1">#print &quot;cache hit!&quot;</span>
            <span class="k">return</span> <span class="n">answer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># if it is not calculated before, calculate now</span>
        
        <span class="n">coupling</span> <span class="o">=</span> <span class="mf">0.</span>
        
        <span class="c1">## rotate individual states</span>
        <span class="n">statePart1</span> <span class="o">=</span> <span class="n">singleAtomState</span><span class="p">(</span><span class="n">j1</span><span class="p">,</span> <span class="n">mj1</span><span class="p">)</span>
        <span class="n">dMatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wgd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">j1</span><span class="p">)</span> 
        <span class="n">statePart1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">dMatrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">statePart1</span><span class="p">))</span>
        
        <span class="n">statePart2</span> <span class="o">=</span> <span class="n">singleAtomState</span><span class="p">(</span><span class="n">j2</span><span class="p">,</span> <span class="n">mj2</span><span class="p">)</span>
        <span class="n">dMatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wgd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">j2</span><span class="p">)</span>
        <span class="n">statePart2</span> <span class="o">=</span> <span class="n">dMatrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">statePart2</span><span class="p">)</span>
        
        <span class="c1">## find first common index and start summation</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">j1</span><span class="p">,</span><span class="n">j2</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">mj</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">start</span><span class="p">,</span><span class="n">start</span><span class="p">,</span><span class="n">floor</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span>
            <span class="n">coupling</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getAngular</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">mj</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="p">,</span><span class="n">mj</span><span class="p">)</span><span class="o">*</span>\
                        <span class="p">(</span><span class="n">statePart1</span><span class="p">[</span><span class="n">j1</span><span class="o">+</span><span class="n">mj</span><span class="p">]</span><span class="o">*</span><span class="n">statePart2</span><span class="p">[</span><span class="n">j2</span><span class="o">+</span><span class="n">mj</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>

        <span class="c1">## save in memory for later use </span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39; INSERT INTO eFieldCoupling</span>
<span class="s1">                            VALUES (?,?,?, ?,?,?, ?)&#39;&#39;&#39;</span><span class="p">,</span>\
                            <span class="p">[</span><span class="n">l1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">j1</span><span class="p">,</span><span class="n">j1</span><span class="o">+</span><span class="n">mj1</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">j2</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">j2</span><span class="o">+</span><span class="n">mj2</span><span class="p">,</span><span class="n">coupling</span><span class="p">]</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
        
        <span class="c1"># return result</span>
        
        <span class="k">return</span> <span class="n">coupling</span>
    
<span class="c1"># =================== E FIELD Coupling (END) ===================</span>

<span class="c1"># =================== B FIELD Coupling (START) ===================</span>

<span class="c1"># only available in dev version</span>

<span class="c1"># =================== B FIELD Coupling (END) ===================</span>

</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Nikola ibali.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.9 beta',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>